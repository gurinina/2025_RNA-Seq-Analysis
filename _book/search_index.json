[["index.html", "PHAR520: Applied Omics Science for Drug Discovery and Development ModuleII: 2025_RNA-Seq-Analysis RNA-seq analysis workshop", " PHAR520: Applied Omics Science for Drug Discovery and Development ModuleII: 2025_RNA-Seq-Analysis RNA-seq analysis workshop The published version for this module can be found on my bookdown site 2024_RNA-seq-analysis. "],["differential-gene-expression-dge-analysis-overview.html", "Chapter 1 Differential gene expression (DGE) analysis overview 1.1 Review of the dataset 1.2 Setting up 1.3 Differential gene expression analysis overview", " Chapter 1 Differential gene expression (DGE) analysis overview The goal of RNA-seq is to perform differential expression testing to determine which genes are expressed at different levels between conditions. These genes can offer biological insight into the processes affected by the condition(s) of interest. To determine the expression levels of genes, our RNA-seq workflow follows the steps detailed in the image below inside the box. All steps are performed on the command line (Linux/Unix) through the generation of read counts per gene as discussed in Corey’s lectures. The differential expression analysis and any downstream functional analysis are generally performed in R using R packages specifically designed for the complex statistical analyses required to determine whether genes are differentially expressed starting from the count matrices. In the next few lessons, we will walk you through an end-to-end gene-level RNA-seq differential expression workflow using various R packages. We will start with the count matrix, perform exploratory data analysis for quality assessment and to explore the relationship between samples, perform differential expression analysis, and visually explore the results prior to performing downstream functional analysis. 1.1 Review of the dataset We will be using the full count matrix from the RNA-seq dataset that is part of a larger study described in Kenny PJ et al, Cell Rep 2014 investigating the interactions between genes potentially involved in Fragile X syndrome (FXS). FXS is a genetic disorder and the leading cause of inherited intellectual disabilities like autism. FXS is caused by aberrant production of a protein called Fragile X Messenger Ribonucleoprotein (FMRP) that is needed for brain development. People who have FXS do not make this protein. The authors demonstrated that FMRP associates with another RNA-binding protein MOV10 (Mov10 RISC Complex RNA Helicase) and acts to regulate the translation of a subset of RNAs. What is the function of FMRP and MOV10? FMRP is “most commonly found in the brain, is essential for normal cognitive development and female reproductive function. Mutations of this gene can lead to fragile X syndrome, mental retardation, premature ovarian failure, autism, Parkinson’s disease, developmental delays and other cognitive deficits.” - from wikipedia MOV10 MOV10 has been shown to associate with the 3’ UTR of mRNAs as part of its role in the RNA-induced silencing complex (RISC). MOV10 is an RNA helicase believed to assist in the unwinding of RNA duplexes. MOV10 is associated with FMRP in the context of the microRNA pathway. MOV10 has a role in regulating translation: it facilitates microRNA-mediated translation of some RNAs, but it also increases expression of other RNAs. The aim of the RNAseq part of the study was to characterize the transcription expression patterns of FMRP and MOV10 to identify overlapping target genes which would suggest that these genes are regulated by the MOV10-FMRP complex. Model for MOV10-FMRP** Association in Translation Regulation. Top: fate of RNAs bound by MOV10. MOV10** binds the 3′ UTR-encoded G-rich structure to reveal MREs for subsequent AGO2 association. Middle: fate of RNAs bound by FMRP. FMRP binds RNAs in the nucleus. Upon export, FMRP recruits MOV10, which ultimately unwinds MREs for association with AGO2. Bottom: FMRP recruits MOV10 to RNAs; however, binding of both FMRP and MOV10 in proximity of MRE blocks association with AGO2. Red line indicates MRE. RNA-seq was performed on HEK293F cells that were either transfected with a MOV10 transgene, or siRNA to knock down Mov10 expression, or non-specific (irrelevant) siRNA. This resulted in 3 conditions Mov10 oe (over expression), Mov10 kd (knock down) and Irrelevant kd, respectively. The number of replicates is as shown below. Using these data, we will evaluate transcriptional patterns associated with perturbation of MOV10 expression. Please note that the irrelevant siRNA will be treated as our control condition. Links to raw data [GEO]: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE51443 “Gene Expression Omnibus” [SRA]: https://trace.ncbi.nlm.nih.gov/Traces/sra/?study=SRP031507 “Sequence Read Archive” Our questions: What patterns of expression can we identify with the loss or gain of MOV10? Are there any genes that are differentially expressed between the two conditions? Are there any genes shared between the two conditions? 1.2 Setting up Go to the File menu and to the lessons directory and open 09-DGE_codebook.Rmd. This will open in the script editor in the top left hand corner. This is where we will be running all commands required for this analysis, and like last time this is where you will enter the code/answers for your homework assignment. Please save this as something with your name in it (e.g. firstname_lastname_09-DGE_codebook.Rmd). 1.2.1 Loading libraries For this analysis we will be using several R packages, some which have been installed from CRAN and others from Bioconductor. To use these packages (and the functions contained within them), we need to load the libraries. ## Setup Bioconductor and CRAN libraries used library(tidyverse) library(RColorBrewer) library(DESeq2) library(pheatmap) library(ggplot2) library(ggrepel) 1.2.2 Loading data To load the data into our current environment, we will be using the read.table function. We need to provide the path to each file and also specify arguments to let R know that we have a header (header = T) and the first column is our row names (row.names = 1). By default the function expects tab-delimited files, which is what we have. ## Load in data data &lt;- read.table(&quot;data/Mov10_full_counts.txt&quot;, header = T, row.names = 1) meta &lt;- read.table(&quot;data/Mov10_full_meta.txt&quot;, header = T, row.names = 1) Use class() to inspect our data and make sure we are working with data frames: ### Check classes of the data we just brought in class(meta) ## [1] &quot;data.frame&quot; class(data) ## [1] &quot;data.frame&quot; 1.2.3 Viewing data Make sure your datasets contain the expected samples / information before proceeding to perfom any type of analysis. rownames(meta) ## [1] &quot;Irrel_kd_1&quot; &quot;Irrel_kd_2&quot; &quot;Irrel_kd_3&quot; &quot;Mov10_kd_2&quot; &quot;Mov10_kd_3&quot; ## [6] &quot;Mov10_oe_1&quot; &quot;Mov10_oe_2&quot; &quot;Mov10_oe_3&quot; names(data) ## [1] &quot;Mov10_kd_2&quot; &quot;Mov10_kd_3&quot; &quot;Mov10_oe_1&quot; &quot;Mov10_oe_2&quot; &quot;Mov10_oe_3&quot; ## [6] &quot;Irrel_kd_1&quot; &quot;Irrel_kd_2&quot; &quot;Irrel_kd_3&quot; You’ll notice the colnames of the data are the sample names, and the rownames of the metadata are the sample names. This is important as we will be merging the metadata with the data based on the sample names. 1.3 Differential gene expression analysis overview So what does this count data actually represent? The count data used for differential expression analysis represents the number of sequence reads that originated from a particular gene. The higher the number of counts, the more reads associated with that gene, and the assumption that there was a higher level of expression of that gene in the sample. With differential expression analysis, we are looking for genes that change in expression between two or more groups (defined in the metadata) - case vs. control - correlation of expression with some variable or clinical outcome Why does it not work to identify differentially expressed gene by ranking the genes by how different they are between the two groups (based on fold change values)? More often than not, there is much more going on with your data than what you are anticipating. Genes that vary in expression level between samples is a consequence of not only the experimental variables of interest but also due to extraneous sources. The goal of differential expression analysis to determine the relative role of these effects, and to separate the “interesting” from the “uninteresting”. The “uninteresting” presents as sources of variation in your data, and so even though the mean expression levels between sample groups may appear to be quite different, it is possible that the difference is not actually significant. This is illustrated for ‘GeneA’ expression between ‘untreated’ and ‘treated’ groups in the figure below. The mean expression level of geneA for the ‘treated’ group is twice as large as for the ‘untreated’ group, but the variation between replicates indicates that this may not be a significant difference. We need to take into account the variation in the data (and where it might be coming from) when determining whether genes are differentially expressed. The goal of differential expression analysis is to determine, for each gene, whether the differences in expression (counts) between groups is significant given the amount of variation observed within groups (replicates). To test for significance, we need an appropriate statistical model that accurately performs normalization (to account for differences in sequencing depth, etc.) and variance modeling (to account for few numbers of replicates and large dynamic expression range). 1.3.1 RNA-seq count distribution To determine the appropriate statistical model, we need information about the distribution of counts. To get an idea about how RNA-seq counts are distributed, let’s plot the counts for a single sample, ‘Mov10_oe_1’: ggplot(data) + geom_histogram(aes(x = Mov10_oe_1), stat = &quot;bin&quot;, bins = 200) + xlab(&quot;Raw expression counts&quot;) + ylab(&quot;Number of genes&quot;) If we zoom in close to zero, we can see a large number of genes with counts of zero: ggplot(data) + geom_histogram(aes(x = Mov10_oe_1), stat = &quot;bin&quot;, bins = 200) + xlim(-5, 500) + xlab(&quot;Raw expression counts&quot;) + ylab(&quot;Number of genes&quot;) These images illustrate some common features of RNA-seq count data, including a low number of counts associated with a large proportion of genes, and a long right tail due to the lack of any upper limit for expression. 1.3.2 Modeling count data Count data is often modeled using the binomial distribution. The Binomial distribution is a common probability distribution that models the probability of obtaining one of two outcomes under a given number of parameters. It summarizes the number of successes in a fixed number of trials when each trial has two possible outcomes. For example, a coin toss is typically modeled using a binomial distribution, where the number of successes (e.g., heads) in a fixed number of trials (e.g., 10 coin tosses) when each trial has two possible outcomes (e.g., heads or tails) and the probability of success is constant. However, not all count data can be fit with the binomial distribution. The binomial is based on discrete events and used in situations when you have a certain number of cases. The binomial distribution is used to model scenarios where there are two possible outcomes, such as “success” or “failure,” over a fixed number of trials. For example, flipping a coin 10 times and counting the number of “heads” out of those 10 flips follows a binomial distribution with a probability of success (\\(p\\)) equal to 0.5. When the number of cases is very large (i.e. people who buy lottery tickets), but the probability of an event is very small (probability of winning), the Poisson distribution is used to model these types of count data. With RNA-seq data, for each sample we have millions of reads being sequenced and the probability of a read mapping to a gene is extremely low. Thus, it would be an appropriate situation to use the Poisson distribution. However, a unique property of this distribution is that the mean == variance given by the single parameter \\(\\lambda\\). For us to apply a poisson distribution to our data, we first need to find out whether our data fulfills the criteria to use the poisson distribution. To do that we can plot the mean versus variance for the ‘Mov10 overexpression’ replicates: To calculate the mean and variance of our data, we will use the apply function. The apply function allows you to apply a function to the margins (rows or columns) of a matrix. The syntax for apply is as follows: apply(X, MARGIN, FUN), where X is a matrix, MARGIN is the margin of the matrix to apply the function to (1 = rows, 2 = columns), and FUN is the function to apply. We will use MARGIN = 1 to apply the function mean and variance of the counts for each row (gene) across the ‘Mov10 overexpression’ replicates. We will then create a data frame with the mean and variance of the counts for each gene. # calculate the mean and variance of the counts for each gene mean_counts &lt;- apply(data[, 3:5], 1, mean) variance_counts &lt;- apply(data[, 3:5], 1, var) # for ggplot we need the data to be in a data.frame df &lt;- data.frame(mean_counts, variance_counts) Run the following code to plot the mean versus variance for the ‘Mov10 overexpression’ replicates: ggplot(df) + geom_point(aes(x = mean_counts, y = variance_counts)) + geom_line(aes(x = mean_counts, y = mean_counts, color = &quot;red&quot;)) + scale_y_log10() + scale_x_log10() By plotting the mean versus the variance of our data we can easily see that the variance &gt; mean and therefore it does not fit the Poisson distribution. Genes having higher mean counts have even higher variance. Also for gene having low mean counts, there is a scatter of points and we can see that there is variability even in the variance. To account for this extra variance we need a new model. The model that fits best, given this type of variability between replicates, is the Negative Binomial (NB) model. Essentially, the NB model is a good approximation for data where the variance &gt; mean, as is the case with RNA-seq count data. 1.3.3 Improving mean estimates (i.e. reducing variance) with biological replicates The variance or scatter tends to reduce as we increase the number of biological replicates (the distribution will approach the Poisson distribution with increasing numbers of replicates). The value of additional replicates is that as you add more data (replicates), you get increasingly precise estimates of group means, and ultimately greater confidence in the ability to distinguish differences between sample classes (i.e. more DE genes). The figure below shows how the number of differentially expressed (DE) genes identified is influenced by sequencing depth and number of replicates [1]. Notice that increasing the number of replicates identifies more DE genes compared to increasing sequencing depth. This is because most of the biological variability occurs between samples. As a result, having more replicates typically yields better results than increasing sequencing depth, as it captures natural biological variability more effectively and leads to more accurate estimates of within-group variation. While increasing sequencing depth reduces technical noise, it has less impact on detecting DE genes since it doesn’t account for biological variability. Generally, a minimum sequencing depth of 20-30 million reads per sample is recommended, though successful RNA-seq experiments have been conducted with as few as 10 million reads when enough replicates are included. NOTE Biological replicates represent multiple samples (i.e. RNA from different mice) representing the same sample class Technical replicates represent the same sample (i.e. RNA from the same mouse) but with technical steps replicated Usually biological variance is much greater than technical variance, so we do not need to account for technical variance to identify biological differences in expression Don’t spend money on technical replicates - biological replicates are much more useful 1.3.4 Differential expression analysis workflow To model counts appropriately when performing a differential expression analysis, there are a number of software packages that have been developed for differential expression analysis of RNA-seq data. Even as new methods are continuously being developed a few tools are generally recommended as best practice, e.g. DESeq2 and EdgeR. Both these tools use the negative binomial model, employ similar methods, and typically, yield similar results. They are pretty stringent, and have a good balance between sensitivity and specificity (reducing both false positives and false negatives). Here is a comparison of the three most highy used software packages for differential expression analysis. No single method is optimal under all circumstances, for example, limma works best when sample number is high, and edgeR and DESeq2 perform well for small sample sizes. It is also difficult to compare analysis methods due to different procedures in calculating pvalues. We will be using DESeq2 for the DE analysis, and the analysis steps with DESeq2 are shown in the flowchart below. DESeq2 first normalizes the count data to account for differences in library sizes and RNA composition between samples. Then, we will use the normalized counts to make some plots for QC at the gene and sample level. The final step is to use the appropriate functions from the DESeq2 package to perform the differential expression analysis. We will go in-depth into each of these steps in the following lessons, but additional details and helpful suggestions regarding DESeq2 can be found in the DESeq2 vignette. As you go through this workflow and questions arise, you can reference the vignette from within RStudio: vignette(&quot;DESeq2&quot;) This is very convenient, as it provides a wealth of information at your fingertips! Be sure to use this as you need during the workshop. "],["count-normalization.html", "Chapter 2 Count normalization 2.1 Normalization 2.2 Count normalization of Mov10", " Chapter 2 Count normalization 2.1 Normalization The first step in the DE analysis workflow is count normalization, which is necessary to make accurate comparisons of gene expression between samples. The counts of mapped reads for each gene is proportional to the expression of RNA (“interesting”) in addition to many other factors (“uninteresting”). Normalization is the process of scaling raw count values to account for the “uninteresting” factors. In this way the expression levels are more comparable between and/or within samples. The main factors often considered during normalization are: Sequencing depth: Accounting for sequencing depth is necessary for comparison of gene expression between samples. In the example below, each gene appears to have doubled in expression in Sample A relative to Sample B, however this is a consequence of Sample A having double the sequencing depth. NOTE: In the figure above, each pink and green rectangle represents a read aligned to a gene. Reads connected by dashed lines connect a read spanning an intron. Gene length: Accounting for gene length is necessary for comparing expression between different genes within the same sample. In the example, Gene X and Gene Y have similar levels of expression, but the number of reads mapped to Gene X would be many more than the number mapped to Gene Y because Gene X is longer. RNA composition: RNA composition bias arises when a few highly expressed genes dominate the overall expression profile of a sample. Accounting for RNA composition is recommended for accurate comparison of expression between samples, and is particularly important when performing differential expression analyses [1]. In the example, if we were to divide each sample by the total number of counts to normalize, the counts would be greatly skewed by the DE gene, which takes up most of the counts for Sample A, but not Sample B. Most other genes for Sample A would be divided by the larger number of total counts and appear to be less expressed than those same genes in Sample B. While normalization is essential for differential expression analyses, it is also necessary for exploratory data analysis, visualization of data, and whenever you are exploring or comparing counts between or within samples. 2.1.1 Common normalization methods Several common normalization methods exist to account for these differences: TPM is very similar to RPKM and FPKM. The only difference is the order of operations. Here’s how you calculate TPM: For example, here’s how you would calculate TPM for a gene in a sample: Divide the read counts by the length of each gene in kilobases. This gives you reads per kilobase (RPK). \\[ RPK = \\frac{reads}{gene length (kb)} \\] Count up all the RPK values in a sample and divide this number by 1,000,000. This is your “per million” scaling factor. \\[ \\text{Per million scaling factor} = \\frac{\\sum RPK}{1,000,000} \\] Divide the RPK values by the “per million” scaling factor. This gives you TPM. \\[ TPM = \\frac{RPK}{\\text{Per million scaling factor}} \\] The key idea here is that TPM normalizes for both gene length and sequencing depth, making it easier to compare the relative abundance of genes across different samples, regardless of how many total reads were generated. Normalization method Description Accounted factors Recommendations for use TPM (transcripts per kilobase million) counts per length of transcript (kb) per million reads mapped sequencing depth and gene length gene count comparisons within a sample or between samples of the same sample group; NOT for DE analysis RPKM/FPKM (reads/fragments per kilobase of exon per million reads/fragments mapped) similar to TPM sequencing depth and gene length gene count comparisons between genes within a sample; NOT for between sample comparisons or DE analysis DESeq2’s median of ratios [1] counts divided by sample-specific size factors determined by median ratio of gene counts relative to geometric mean per gene sequencing depth and RNA composition gene count comparisons between samples and for DE analysis; NOT for within sample comparisons EdgeR’s trimmed mean of M values (TMM) [2] uses a weighted trimmed mean of the log expression ratios between samples sequencing depth, RNA composition gene count comparisons between samples and for DE analysis; NOT for within sample comparisons 2.1.2 TPM (Not Recommended) Step 1: Calculate Reads Per Kilobase (RPK) To calculate RPK for each gene in each sample, divide the read counts by the gene length in kilobases. Gene Sample 1 (reads) Sample 2 (reads Length Gene A 300 600 1 kb Gene B 500 400 2 kb Sample 1: - Gene A RPK = 300 reads / 1 kb = 300 - Gene B RPK = 500 reads / 2 kb = 250 Sample 2: - Gene A RPK = 600 reads / 1 kb = 600 - Gene B RPK = 400 reads / 2 kb = 200 Gene Sample 1 (RPK) Sample 2 (RPK) Gene A 300 600 Gene B 250 200 Step 2: Calculate the Per-Million Scaling Factor Sum the RPK values in each sample and divide by 1,000,000. Sample 1: - Total RPK = 300 + 250 = 550 - Scaling Factor = 550 / 1,000,000 = 0.00055 Sample 2: - Total RPK = 600 + 200 = 800 - Scaling Factor = 800 / 1,000,000 = 0.0008 Step 3: Calculate TPM Now, divide each gene’s RPK by the per-million scaling factor to get the TPM. Sample 1: - Gene A TPM = 300 / 0.00055 = 545,455 - Gene B TPM = 250 / 0.00055 = 454,545 Sample 2: - Gene A TPM = 600 / 0.0008 = 750,000 - Gene B TPM = 200 / 0.0008 = 250,000 Gene Sample 1 (TPM) Sample 2 (TPM) Gene A 545,455 750,000 Gene B 454,545 250,000 TPM normalizes read counts by the total reads in a sample, allowing comparisons between genes while accounting for gene length. However, it does not account for the variability inherent in count data or overdispersion, making statistical testing on these values unreliable. 2.1.3 RPKM/FPKM (Not Recommended) Using RPKM/FPKM normalization means the total normalized counts will vary between samples, making direct comparisons between genes unreliable. Gene Sample A Sample B XCR1 5.5 5.5 WASHC1 73.4 21.8 … … … Total RPKM 1,000,000 1,500,000 For example, even though both samples show XCR1 as 5.5, they cannot be directly compared because their total counts differ. Conclusion: Tools like DESeq2 or edgeR are better suited for differential expression analysis, as they: Use raw counts for more accurate modeling. Apply statistical modeling (e.g., Negative Binomial) to account for variance across replicates. 2.1.4 DESeq2 Normalization: Median of Ratios Method For differential expression analysis, gene length need not be factored in; however, sequencing depth and RNA composition must be considered. The median of ratios method neutralizes these differences. This method involves several steps, even though from the user-end it appears as a single function call in DESeq2. Step 1: Create a Pseudo-reference Sample (Row-wise Geometric Mean) The geometric mean of a set of \\(n\\) positive numbers \\(x_1, x_2, \\dots, x_n\\) is defined as: \\[ \\text{Geometric Mean} = \\left( \\prod_{i=1}^{n} x_i \\right)^{\\frac{1}{n}} \\] For each gene, a pseudo-reference sample is created that is equal to the geometric mean across all samples, reducing the impact of extreme values. Gene Sample A Sample B Pseudo-reference Sample EF2A 1489 906 sqrt(1489 * 906) = 1161.5 ABCD1 22 13 sqrt(22 * 13) = 17.7 … … … … Step 2: Calculate the Ratio of Each Sample to the Reference For every gene in a sample, calculate the ratio of the sample count to the reference (sample/ref). This is performed for each sample in the dataset, resulting in ratios for most genes that are similar, as depicted below: Gene Sample A Sample B Pseudo-reference Sample Ratio of Sample A/Ref Ratio of Sample B/Ref EF2A 1489 906 1161.5 1489/1161.5 = 1.28 906/1161.5 = 0.78 ABCD1 22 13 17.7 22/17.7 = 1.24 13/17.7 = 0.73 MEFV 793 410 570.2 793/570.2 = 1.39 410/570.2 = 0.72 … … … … … … Step 3: Calculate the Normalization Factor for Each Sample (Size Factor) The median value of all ratios for a given sample is calculated as the normalization factor (size factor): normalization_factor_sampleA &lt;- median(c(1.28, 1.24, 1.39, 1.35, 0.59)) normalization_factor_sampleB &lt;- median(c(0.78, 0.73, 0.72, 0.74, 1.35)) The figure below illustrates the distribution of values for the ratios across all genes in a single sample. This method is robust as it assumes that not all genes are differentially expressed, allowing normalization factors to account for both sequencing depth and RNA composition efficiently. Step 4: Calculate the Normalized Count Values Using the Normalization Factor Each raw count value in a given sample is divided by that sample’s normalization factor to generate normalized count values across all genes: Gene Sample A Sample B EF2A 1489 / 1.3 = 1145.39 906 / 0.77 = 1176.62 ABCD1 22 / 1.3 = 16.92 13 / 0.77 = 16.88 … … … Note that normalized count values may not always be whole numbers. 2.1.5 Summary of Key Reasons for Using DESeq2 Median of Ratios: This method accounts for sequencing depth and RNA composition, making it more appropriate for RNA-Seq data analysis. Geometric Mean: It creates a pseudo-reference that reduces sensitivity to extreme values, affording more stable estimates. Normalization Procedures: It ensures reliable comparisons of gene expression across samples by mitigating bias from technical variations, leading to more accurate differential expression analysis. This combination of methodologies allows DESeq2 to provide robust results, enhancing the identification of differentially expressed genes in complex biological datasets. Exercise points = +1 Determine the normalized counts for your gene of interest, PD1, given the raw counts and size factors below. NOTE: You will need to run the code below to generate the raw counts dataframe (PD1) and the size factor vector (size_factors), then use these objects to determine the normalized counts values: # Raw counts for PD1 PD1 &lt;- c(21, 58, 17, 97, 83, 10) names(PD1) &lt;- paste0(&quot;Sample&quot;, 1:6) PD1 &lt;- data.frame(PD1) PD1 &lt;- t(PD1) # Size factors for each sample size_factors &lt;- c(1.32, 0.7, 1.04, 1.27, 1.11, 0.85) # Your code here 2.2 Count normalization of Mov10 Now that we know the theory of count normalization, we will normalize the counts for the Mov10 dataset using DESeq2. This requires a few steps: Ensure the row names of the metadata dataframe are present and in the same order as the column names of the counts dataframe. Create a DESeqDataSet object Generate the normalized counts 2.2.1 1. Match the metadata and counts data We should always make sure that we have sample names that match between the two files, and that the samples are in the right order. DESeq2 will output an error if this is not the case. ### Check that sample names match in both files all(colnames(data) %in% rownames(meta)) ## [1] TRUE all(colnames(data) == rownames(meta)) ## [1] FALSE The colnames of our data don’t match the rownames of our metadata so we need to reorder them. We can use the match function: idx &lt;- match(rownames(meta), colnames(data)) data &lt;- data[, idx] all(colnames(data) == rownames(meta)) ## [1] TRUE Exercise points = +2 Suppose we had sample names matching in the counts matrix and metadata file, but they were out of order. Write the line(s) of code required to create a new matrix with columns ordered such that they were identical to the row names of the metadata. # write the code to reorder the columns of the &#39;counts&#39; matrix to match the # rownames of the metadata # check that the rownames of the metadata match the colnames of the &#39;counts&#39; # matrix 2.2.2 2. Create DESEq2 object Bioconductor software packages often define and use a custom class within R for storing data (input data, intermediate data and also result data). These custom data structures are similar to lists in that they can contain multiple different data types/structures within them. But, unlike lists they have pre-specified data slots, which hold specific types/classes of data. The data stored in these pre-specified slots can be accessed by using specific package-defined functions. Let’s start by creating the DESeqDataSet object and then we can talk a bit more about what is stored inside it. To create the object we will need the count matrix and the metadata table as input. We will also need to specify a design formula. The design formula specifies the column(s) in the metadata table and how they should be used in the analysis. For our dataset we only have one column we are interested in, that is ~sampletype. This column has three factor levels, which tells DESeq2 that for each gene we want to evaluate gene expression change with respect to these different levels. ## Create DESeq2Dataset object dds &lt;- DESeqDataSetFromMatrix(countData = data, colData = meta, design = ~sampletype) You can use DESeq-specific functions to access the different slots and retrieve information, if you wish. For example, suppose we wanted the original count matrix we would use counts(): head(counts(dds[, 1:5])) ## Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 ## 1/2-SBSRNA4 45 31 39 57 41 ## A1BG 77 58 40 71 40 ## A1BG-AS1 213 172 126 256 177 ## A1CF 0 0 0 0 1 ## A2LD1 91 80 50 146 81 ## A2M 9 8 4 10 9 As we go through the workflow we will use the relevant functions to check what information gets stored inside our object. We can also run: slotNames(dds) ## [1] &quot;design&quot; &quot;dispersionFunction&quot; &quot;rowRanges&quot; ## [4] &quot;colData&quot; &quot;assays&quot; &quot;NAMES&quot; ## [7] &quot;elementMetadata&quot; &quot;metadata&quot; 2.2.3 3. Generate the Mov10 normalized counts The next step is to normalize the count data in order to be able to make fair gene comparisons between samples. To perform the median of ratios method of normalization, DESeq2 has a single estimateSizeFactors() function that will generate size factors for us. We will use the function in the example below, but in a typical RNA-seq analysis this step is automatically performed by the DESeq() function, which we will see later. dds &lt;- estimateSizeFactors(dds) By assigning the results back to the dds object we are filling in the slots of the DESeqDataSet object with the appropriate information. We can take a look at the normalization factor applied to each sample using: sizeFactors(dds) ## Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 Mov10_oe_2 ## 1.1224020 0.9625632 0.7477715 1.5646728 0.9351760 1.2016082 1.1205912 ## Mov10_oe_3 ## 0.6534987 Now, to retrieve the normalized counts matrix from dds, we use the counts() function and add the argument normalized=TRUE. normalized_counts &lt;- counts(dds, normalized = TRUE) We can save this normalized data matrix to file for later use: write.table(normalized_counts, file = &quot;data/normalized_counts.txt&quot;, sep = &quot;\\t&quot;, quote = F, col.names = NA) "],["quality-control.html", "Chapter 3 Quality Control 3.1 Sample-level QC 3.2 Gene-level QC 3.3 Mov10 quality assessment and exploratory analysis using DESeq2", " Chapter 3 Quality Control The next step in the DESeq2 workflow is QC, which includes sample-level and gene-level steps to perform QC checks on the count data to help us ensure that the samples/replicates look good. 3.1 Sample-level QC A useful initial step in an RNA-seq analysis is often to assess overall similarity between samples: Which samples are similar to each other, which are different? Does this fit to the expectation from the experiment’s design? What are the major sources of variation in the dataset? To explore the similarity of our samples, we will be performing sample-level QC using Principal Component Analysis (PCA) and hierarchical clustering methods. Our sample-level QC allows us to see how well our replicates cluster together, as well as, observe whether our experimental condition represents the major source of variation in the data. Performing sample-level QC can also identify any sample outliers, which may need to be explored further to determine whether they need to be removed prior to DE analysis. When using these unsupervised clustering methods, log2-transformation of the normalized counts improves the distances/clustering for visualization. DESeq2 uses a regularized log transform (rlog) of the normalized counts for sample-level QC as it moderates the variance across the mean, improving the clustering. Principal Component Analysis (PCA) is a technique used to emphasize variation and highlight strong patterns in a dataset. It is particularly useful for dimensionality reduction, meaning it simplifies large datasets by identifying the directions (or principal components) that explain the greatest variation in the data. For a more detailed introduction to PCA, we recommend watching this StatQuest’s video. Suppose we have a dataset with two samples and four genes. To evaluate the relationship between these samples, we can plot the counts of one sample against the other, with Sample 1 on the x-axis and Sample 2 on the y-axis, as shown below: For PCA analysis, the first step is finding the first principal component (PC1). The first principal component is the direction that maximizes the variance (the sum of squared distances from the mean) and simultaneously minimizes the squared distances between the data points and their projections onto that line. Why? Because variance is essentially the spread (or squared distances) of the data from its mean, and PCA wants to capture as much of this spread as possible. In this example, the most variation is along the diagonal. That is, the largest spread in the data is between the two endpoints of this line. This is called the first principal component, or PC1. The genes at the endpoints of this line (Gene B and Gene C) have the greatest influence on the direction of this line. After determining PC1, PCA assigns each sample a PC1 score, which represents how each sample aligns with this principal component. The score for each sample is calculated by taking the product of each gene’s influence on PC1 and its normalized expression in the sample, and summing these products across all genes. A second line can then be drawn to represent the second principal component (PC2), which captures the second-largest amount of variation in the data. This process can continue for additional principal components. The formula to calculate a sample’s PC1 score is as follows: \\[ \\text{Sample1 PC1 score} = \\sum_{i=1}^{n} (\\text{counts}_{i} \\times \\text{influence}_{i}) \\] Where: \\(\\text{counts}_{i}\\): Normalized expression of gene \\(i\\) in the sample \\(\\text{influence}_{i}\\): Influence of gene \\(i\\) on PC1 While calculating the influence of each gene on PC1 is complex, a key step involves calculating a z-score for each gene. A z-score measures how far a gene’s expression deviates from the mean, and genes with larger z-scores (like Gene B and Gene C in this example) have a greater influence on PC1 because they contribute more to the variation. Briefly, calculating PCA and the influence of each gene on PC1 involves the following steps: 3.1.0.1 Steps to calculate PCA Z-Scores: A z-score transforms the data points, indicating how far a value is from the mean in terms of standard deviations. This standardization adjusts for differences in scale between different genes, allowing for more accurate comparisons. The formula for calculating a z-score for a value \\(x\\) of a gene is: \\[ z = \\frac{x - \\mu}{\\sigma} \\] Where: \\(\\mu\\) is the mean expression of the gene across samples. \\(\\sigma\\) is the standard deviation of the gene expression. Covariance matrix: Covariance measures the degree to which two variables change together. In the context of PCA, we calculate the covariance matrix for standardized (z-scored) gene expressions to understand how genes vary together. A positive covariance indicates that higher values of one gene correspond to higher values of another, while a negative covariance implies that higher values of one gene correspond to lower values of another. After standardizing the data, calculate the covariance between the z-scores of different genes. This will produce a covariance matrix that reveals how gene expressions vary together. In the context of Principal Component Analysis (PCA), the covariance matrix is a crucial component. It captures how variables in the dataset change with respect to one another and is used to determine the principal components. Eigenvectors and Eigenvalues: Find these from the covariance matrix. They reveal the directions (principal components) and their importance (variance explained) in the data. Think of PCA as creating new “axes” or dimensions that capture the most variation in the data. PCA will identify the direction of these axes based on the covariance of the standardized gene expressions that better highlight differences in your data. The take-home message is that if two samples have similar levels of expression for the genes that contribute significantly to PC1, they will have similar PC1 scores and will be plotted close to each other on the PC1 axis. Therefore, we would expect biological replicates (samples from the same condition) to have similar PC1 scores and cluster together. On the other hand, samples from different treatment groups should have different PC1 scores, reflecting their distinct gene expression patterns. This is more easily understood through visualizing example PCA plots. 3.1.0.2 Interpreting PCA plots In real datasets with many samples and genes, PCA reduces the complex, high-dimensional data into a 2-dimensional space, where each sample is represented by its scores for the principal components. Typically, we plot the first two principal components (PC1 and PC2), as they explain the most variation in the data. When interpreting PCA plots, biological replicates (samples from the same condition) should cluster together because they have similar expression patterns for the genes driving variation in PC1. Samples from different treatment groups will often separate along these axes, reflecting differences in their gene expression profiles. This is best understood by looking at example PCA plots, where you can visualize how biological replicates cluster and treatment groups separate based on their gene expression patterns. 3.1.0.3 Interpreting PCA plots example We have an example dataset and a few associated PCA plots below to get a feel for how to interpret them. The metadata for the experiment is displayed below. The main condition of interest is treatment. When visualizing the samples on PC1 and PC2, we can color the points based on different metadata columns to identify potential sources of variation. In the first plot, if we don’t observe a clear separation of samples by treatment, we can explore other factors that may explain the variation. Ideally, our metadata table includes all known sources of variation (such as batch effects, age, or gender), and we can use these factors to color the PCA plot to see if they explain any underlying patterns. We begin by coloring the points in the PCA plot based on the cage factor, but this factor does not seem to explain the variation observed on PC1 or PC2. Next, we color the points by the sex factor. Here, we observe that sex separates the samples along PC2, which is valuable information. We can use this in our model to account for variation due to sex and potentially regress it out to focus on other sources of variation. Next we explore the strain factor and find that it explains the variation on PC1. It’s great that we have been able to identify the sources of variation for both PC1 and PC2. By accounting for it in our model, we should be able to detect more genes differentially expressed due to treatment. Worrisome about this plot is that we see two samples that do not cluster with the correct strain. This would indicate a likely sample swap and should be investigated to determine whether these samples are indeed the labeled strains. If we found there was a switch, we could swap the samples in the metadata. However, if we think they are labeled correctly or are unsure, we could just remove the samples from the dataset. Still we haven’t found if treatment is a major source of variation after strain and sex. So, we explore PC3 and PC4 to see if treatment is driving the variation represented by either of these PCs. We find that the samples separate by treatment on PC3, and are optimistic about our DE analysis since our condition of interest, treatment, is separating on PC3 and we can regress out the variation driving PC1 and PC2. Treatment separating on PC3 indicates that it still contributes to variation, but its effect is smaller and is only captured after accounting for the larger effects (strain, sex).. me stop Exercise points = +5 The figure below was generated from a time course experiment with sample groups ‘Ctrl’ and ‘Sci’ and the following timepoints: 0h, 2h, 8h, and 16h. Determine the sources explaining the variation represented by PC1 and PC2. Ans: Do the sample groups separate well? Ans: Do the replicates cluster together for each sample group? Ans: Are there any outliers in the data? Ans: Should we have any other concerns regarding the samples in the dataset? Ans: 3.1.1 Recommended Resources For further reading and visual examples of PCA, consider resources such as: - StatQuest’s PCA video (Link) - Online tutorials on PCA in bioinformatics. 3.1.2 Hierarchical Clustering Heatmap Similar to PCA, hierarchical clustering is another, complementary method for identifying strong patterns in a dataset and potential outliers. The heatmap displays the correlation of gene expression for all pairwise combinations of samples in the dataset. Since the majority of genes are not differentially expressed, samples generally have high correlations with each other (values higher than 0.80). Samples below 0.80 may indicate an outlier in your data and/or sample contamination. The hierarchical tree can indicate which samples are more similar to each other based on the normalized gene expression values. The color blocks indicate substructure in the data, and you would expect to see your replicates cluster together as a block for each sample group. Additionally, we expect to see samples clustered similar to the groupings observed in a PCA plot. In the plot below, we would be quite concerned about ‘Wt_3’ and ‘KD_3’ samples not clustering with the other replicates. We would want to explore the PCA to see if we see the same clustering of samples. 3.2 Gene-level QC In addition to examining how well the samples/replicates cluster together, there are a few more QC steps. Prior to differential expression analysis it is beneficial to omit genes that have little or no chance of being detected as differentially expressed. This will increase the power to detect differentially expressed genes. The genes omitted fall into three categories: Genes with zero counts in all samples Genes with an extreme count outlier Genes with a low mean normalized counts DESeq2 will perform this filtering by default; however other DE tools, such as EdgeR will not. Filtering is a necessary step, especially when you are using methods other than DESeq2. 3.3 Mov10 quality assessment and exploratory analysis using DESeq2 Now that we have a good understanding of the QC steps normally employed for RNA-seq, let’s implement them for the Mov10 dataset we are going to be working with. 3.3.1 Transform normalized counts using the rlog transformation To improve the distances/clustering for the PCA and heirarchical clustering visualization methods, we need to apply the regularized log transformation (rlog) transformation to the normalized counts. rlog is used for visualizations in RNA-Seq data analysis, particularly with tools like DESeq2, because it stabilizes the variance across different levels of gene expression, making it easier to interpret patterns in the data. Example of Variance Stabilization Raw RNA-Seq count data has different levels of variability: Without stabilization: Lowly expressed genes show high variability between samples (often due to noise), and highly expressed genes show less variability. With stabilization (e.g., rlog or vst): Variance across genes is more evenly distributed, which makes the data easier to work with in analyses like clustering or PCA. The rlog transformation of the normalized counts is only necessary for these visualization methods during this quality assessment. ### Transform counts for data visualization rld &lt;- rlog(dds, blind = TRUE) The blind=TRUE argument results in a transformation unbiased to sample condition information. When performing quality assessment, it is important to include this option. The DESeq2 vignette has more details. The rlog function returns a DESeqTransform object, another type of DESeq-specific object. The reason you don’t just get a matrix of transformed values is because all of the parameters (i.e. size factors) that went into computing the rlog transform are stored in that object. We use this object to plot the PCA and heirarchical clustering figures for quality assessment. 3.3.2 Principal components analysis (PCA) DESeq2 has a built-in function for plotting PCA plots, that uses ggplot2 under the hood. This is great because it saves us having to type out lines of code and having to fiddle with the different ggplot2 layers. In addition, it takes the rlog object as an input directly, hence saving us the trouble of extracting the relevant information from it. The function plotPCA() requires two arguments as input: an rlog object and the intgroup (the column in our metadata that we are interested in). ### Plot PCA plotPCA(rld, intgroup = &quot;sampletype&quot;) What does this plot tell you about the similarity of samples? Does it fit the expectation from the experimental design? By default the function uses the top 500 most variable genes. You can change this by adding the ntop argument and specifying how many genes you want to use to draw the plot. Resources are available to learn how to do more complex inquiries using the PCs. 3.3.3 Hierarchical Clustering Since there is no built-in function for heatmaps in DESeq2 we will be using the pheatmap() function from the pheatmap package. This function requires a matrix/dataframe of numeric values as input, and so the first thing we need to is retrieve that information from the rld object: ### Extract the rlog matrix from the object rld_mat &lt;- assay(rld) ## assay() is function from the &#39;SummarizedExperiment&#39; package that was loaded when you loaded DESeq2 Then we need to compute the pairwise correlation values for samples. We can do this using the cor() function: ### Compute pairwise correlation values rld_cor &lt;- cor(rld_mat) ## cor() is a base R function head(rld_cor) ## check the output of cor(), make note of the rownames and colnames ## Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 ## Irrel_kd_1 1.0000000 0.9999614 0.9999532 0.9997202 0.9997748 0.9996700 ## Irrel_kd_2 0.9999614 1.0000000 0.9999544 0.9996918 0.9997568 0.9996984 ## Irrel_kd_3 0.9999532 0.9999544 1.0000000 0.9996816 0.9997574 0.9997067 ## Mov10_kd_2 0.9997202 0.9996918 0.9996816 1.0000000 0.9999492 0.9994868 ## Mov10_kd_3 0.9997748 0.9997568 0.9997574 0.9999492 1.0000000 0.9996154 ## Mov10_oe_1 0.9996700 0.9996984 0.9997067 0.9994868 0.9996154 1.0000000 ## Mov10_oe_2 Mov10_oe_3 ## Irrel_kd_1 0.9996599 0.9995804 ## Irrel_kd_2 0.9996825 0.9996227 ## Irrel_kd_3 0.9997090 0.9996026 ## Mov10_kd_2 0.9994565 0.9993869 ## Mov10_kd_3 0.9995905 0.9995235 ## Mov10_oe_1 0.9999505 0.9999196 And now to plot the correlation values as a heatmap: ### Plot heatmap pheatmap(rld_cor) Overall, we observe pretty high correlations across the board ( &gt; 0.999) suggesting no outlying sample(s). Also, similar to the PCA plot you see the samples clustering together by sample group. Together, these plots suggest to us that the data are of good quality and we have the green light to proceed to differential expression analysis. Exercise points = +3 The pheatmap function has a number of different arguments that we can alter from default values to enhance the aesthetics of the plot. Try adding the arguments color, border_color, fontsize_row, fontsize_col, show_rownames and show_colnames to your pheatmap. How does your plot change (plot shown below)? Take a look through the help pages (?pheatmap) and identify what each of the added arguments is contributing to the plot. Pheatmap for exercise: library(pheatmap) library(RColorBrewer) heat.colors &lt;- colorRampPalette(brewer.pal(9, &quot;Blues&quot;))(100) pheatmap(rld_cor, color = colorRampPalette(brewer.pal(9, &quot;Blues&quot;))(100)) library(pheatmap) library(RColorBrewer) pheatmap(rld_cor) library(pheatmap) pheatmap(rld_cor) # The color palette &#39;Blues&#39; is a good choice for this heatmap heat.colors &lt;- brewer.pal(9, &quot;Blues&quot;) # Your code here "],["dge-analysis-workflow.html", "Chapter 4 DGE analysis workflow 4.1 Running DESeq2 4.2 DESeq2 differential gene expression analysis workflow", " Chapter 4 DGE analysis workflow Differential expression analysis with DESeq2 involves multiple steps as displayed in the flowchart below in blue. Here’s a more succinct version of your workflow: DESeq2 Workflow Overview: Load Data: Start with raw count data and sample metadata. Normalize Counts: Estimate size factors to adjust for sequencing depth or library size differences. Estimate Dispersion: Calculate gene-wise dispersion, measuring variability in counts not explained by mean expression. Fit Dispersion Trend: Model the relationship between mean counts and dispersion, either parametrically (default) or non-parametrically. Shrink Dispersions: Use empirical Bayes shrinkage to stabilize dispersion estimates, particularly for low-count genes. Empirical Bayes is a version of Bayesian statistics where the prior distribution is estimated from the data itself, rather than being set externally. In empirical Bayes shrinkage, the idea is to estimate a common pattern or distribution (the prior) across all observations (e.g., all genes) and then use this estimated distribution to influence or “shrink” each individual observation. Fit NB Model: Fit a negative binomial model using the shrunken dispersion estimates, capturing variability and estimating log-fold changes. Shrink Log-Fold Changes: Optionally stabilize log-fold changes with regularization, especially for low-expression genes. Statistical Testing: Perform Wald tests to identify differentially expressed genes, providing adjusted p-values for multiple testing. This final step in the differential expression analysis workflow of fitting the raw counts to the NB model and performing the statistical test for differentially expressed genes, is the step we care about. This is the step that performs statistical tests to identify significant differences in gene expression between sample groups. Although the DESeq2 paper was published in 2014, but the package is continually updated and available for use in R through Bioconductor. 4.1 Running DESeq2 Prior to performing the differential expression analysis, it is a good idea to know what sources of variation are present in your data, either by exploration during the QC and/or prior knowledge. Sources of variation refer to anything that causes differences in gene expression across your samples, including biological factors (treatment, sex, age) and technical factors (batch effects, sequencing depth). Ideally, these are all factors in your metadata. These factors lead to variability in the data and can affect your ability to detect meaningful biological signals (like differential expression between treated and control samples).Once you know the major sources of variation, you can remove them prior to analysis or control for them in the statistical model by including them in your design formula. 4.1.1 Set the Design Formula The main purpose of the design formula in DESeq2 is to specify the factors that are influencing gene expression so that their effects can be accounted for or controlled during the analysis. This allows DESeq2 to isolate the effect of the variable you’re primarily interested in while adjusting for other known sources of variation. The design formula should have all of the factors in your metadata that account for major sources of variation in your data. The last factor entered in the formula should be the condition of interest. For example: design(dds) ## ~sampletype This shows that sampletype is the condition of interest and as such is the only covariate. DESeq2 will test for differential expression between the two sample types, adjusting for any other variation. Example If you want to examine the expression differences between treatments as shown below, and you know that major sources of variation include sex and age, then your design formula would be: design &lt;- ~ sex + age + treatment This allows DESeq2 to adjust for sex and age while testing for differences in treatment. Why is this important? Including known sources of variation (like sex and age) ensures any gene expression differences are due to the condition of interest (e.g., treatment), not confounded by other factors. Steps to set the design formula: 1. Identify your factor of interest (e.g., treatment). 2. Determine any confounders (e.g., sex, age). 3. Write the formula, placing the factor of interest last. 4. Use PCA to ensure all relevant factors are included. Exercise points = +3 Suppose you wanted to study the expression differences between the two age groups in the metadata shown above, and major sources of variation were sex and treatment, how would the design formula be written? # Your code here Based on our Mov10 metadata dataframe, which factors could we include in our design formula? Ans: What would you do if you wanted to include a factor in your design formula that is not in your metadata? Ans: 4.1.2 MOV10 Differential Expression Analysis Now that we understand how to specify the model in DESeq2, we can proceed with running the differential expression pipeline on the raw count data. Running Differential Expression in Two Lines of Code To obtain differential expression results from our raw count data, we only need to run two lines of code! First, we create a DESeqDataSet, as we did in the ‘Count normalization’ lesson, specifying the location of our raw counts and metadata, and applying our design formula: ## Create DESeq object dds &lt;- DESeqDataSetFromMatrix(countData = data, colData = meta, design = ~sampletype) Next, we run the actual differential expression analysis with a single call to the DESeq() function. This function handles everything—from normalization to linear modeling—all in one step. During execution, DESeq2 will print messages detailing the steps being performed: estimating size factors, estimating dispersions, gene-wise dispersion estimates, modeling the mean-dispersion relationship, and statistical testing for differential expression. ## Run analysis dds &lt;- DESeq(dds) By re-assigning the result to back to the same variable name (dds), we update our DESeqDataSet object, which will now contain the results of each step in the analysis, effectively filling in the slots of our DESeqDataSet object. 4.2 DESeq2 differential gene expression analysis workflow With these two lines of code, we have completed the core steps in the DESeq2 differential gene expression analysis. The key steps in this workflow are summarized below: In the following sections, we will explore each step in detail to better understand how DESeq2 performs the statistical analysis and what metrics we should focus on to evaluate the quality of the results. 4.2.1 Step 1: Estimate size factors The first step in the differential expression analysis is to estimate the size factors, which is exactly what we already did to normalize the raw counts. DESeq2 will automatically estimate the size factors when performing the differential expression analysis. However, if you have already generated the size factors using estimateSizeFactors(), as we did earlier, then DESeq2 will use these values. To normalize the count data, DESeq2 calculates size factors for each sample using the median of ratios method discussed previously in the Count normalization (Chapter 2) lesson. 4.2.1.1 MOV10 DE analysis: examining the size factors Let’s take a quick look at size factor values we have for each sample: ## Check the size factors sizeFactors(dds) ## Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 Mov10_oe_2 ## 1.1224020 0.9625632 0.7477715 1.5646728 0.9351760 1.2016082 1.1205912 ## Mov10_oe_3 ## 0.6534987 Take a look at the total number of reads for each sample: ## Total number of raw counts per sample colSums(counts(dds)) ## Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 Mov10_oe_2 ## 22687366 19381680 14962754 32826936 19360003 23447317 21713289 ## Mov10_oe_3 ## 12737889 How do the numbers correlate with the size factor? # Your code here 4.2.2 Step 2: Estimate Gene-wise Dispersion The next step in differential expression analysis is estimating gene-wise dispersions. Understanding dispersion is crucial in RNA-Seq analysis. What is Dispersion? Dispersion measures the variability in gene expression that cannot be explained by the mean expression levels alone. It captures the extra-Poisson variability observed in RNA-Seq data, where the variance tends to exceed the mean due to biological and technical factors. In DESeq2, dispersion reflects the variability in gene expression for a given mean count and is characterized by: Lower mean counts: Higher dispersion (more variability). Higher mean counts: Lower dispersion (less variability). The plot below illustrates the relationship between mean expression and variance: each black dot represents a gene, showing that variance can be predicted more reliably for genes with higher mean counts, while lower mean counts exhibit greater variability. Modeling Dispersion Using the Negative Binomial Distribution DESeq2 utilizes the Negative Binomial (NB) distribution to model RNA-Seq count data, effectively managing overdispersion, which is common in biological data. The two key parameters of the NB model are the mean expression level and the dispersion. For each gene \\(i\\), the observed count \\(Y_{ij}\\) in sample \\(j\\) is modeled as: \\[ Y_{ij} \\sim \\text{NB}(\\mu_{ij}, \\alpha_{i}) \\] Where: - \\(Y_{ij}\\) is the observed count for gene \\(i\\) in sample \\(j\\). - \\(\\mu_{ij}\\) is the expected normalized count for gene \\(i\\). - \\(\\alpha_{i}\\) is the gene-specific dispersion parameter. 4.2.3 Step 3: Fit Curve to Gene-wise Dispersion Estimates After estimating gene-wise dispersions using maximum likelihood, DESeq2 fits a global trend to model how dispersion changes as a function of mean expression across all genes. This process stabilizes the dispersion estimates, especially for low-count genes. Low-count genes with more uncertain dispersion estimates are pulled closer to the global trend. Genes with higher counts or more reliable estimates will be shrunk less. Why is Shrinkage Important? Shrinkage improves the reliability of dispersion estimates, making them more stable for genes with low or moderate counts, which typically have noisier estimates. This reduces the influence of random fluctuations and results in more accurate estimates for downstream differential expression testing. Additionally, shrinkage helps to reduce false positives in differential expression analysis, ensuring that estimates for these genes are more reliable for subsequent testing. Genes with extremely high dispersion values (outliers) may demonstrate variability that is unexpected for their mean expression levels and are typically not shrunk. These genes are often biological outliers or affected by technical issues. 4.2.4 Step 4: Assessing Model Fit with Dispersion Plots After shrinkage, it’s essential to evaluate how well the model fits the data through dispersion plots. Ideally, most genes should scatter around the fitted curve, with dispersions decreasing as mean expression increases. Unusual patterns, such as points far from the curve, may indicate data quality issues, like outliers or contamination. Using DESeq2’s plotDispEsts() function visualizes the fit of the model and the extent of shrinkage across genes. 4.2.4.1 Examples of Problematic Dispersion Plots Certainly! Problematic dispersion plots in RNA-Seq analysis, particularly when using tools like DESeq2, can arise from various issues. Here are some reasons that could lead to visual discrepancies in dispersion plots: Reasons for Problematic Dispersion Plots Low Count Data: High Variability: Genes with low expression levels often exhibit greater variability (higher dispersion) across replicates, leading to noisy estimates. Unstable Estimates: With few counts, it’s difficult to obtain reliable dispersion estimates, resulting in significant scattering in the plot. Outliers in the Data: Biological Outliers: Certain genes may genuinely exhibit high variability due to biological conditions (e.g., activation in response to stimuli), leading to higher dispersion estimates. Technical Outliers: Poor quality samples or technical errors in sequencing (e.g., contamination or failed PCR) can result in erroneous high counts for certain genes, affecting overall variability. Batch Effects: Differences in sequencing runs or sample processing can introduce variability independent of biological differences. If not normalized, batch effects can distort dispersion estimates, making it seem like certain genes are more variable than they truly are. Unequal Group Sizes: Uneven distribution of samples across experimental conditions can affect dispersion estimates, particularly if one group has fewer replicates or more variability. Unaccounted Biological Variation: Biological variability among samples or genes that is not captured by the experimental design can affect estimates. For instance, genes involved in complex pathways may show higher dispersion due to interactions. Data Quality Issues: Problems with sample handling, library construction, or sequencing can introduce discrepancies in data that visually manifest as unexpected dispersion. 4.2.5 Assessing and Addressing Issues To tackle issues identified in problematic dispersion plots: Quality Control: Always perform thorough quality control checks on your raw sequencing data to identify outliers and poorly performing samples. Filtering: Remove low-count genes or outliers that might skew your data before running the analysis. Increasing Replicates: Where possible, aim for more replicates to stabilize dispersion estimates, particularly for low-expressed genes. Model Evaluation: Consider exploring different statistical models if patterns suggest that the negative binomial model is not a good fit. Visual Inspection: Regularly visualize data through various methods (e.g., PCA, heatmaps, dispersion plots) to check for quality and consistency. By understanding the potential causes for problematic dispersion plots, you can troubleshoot and improve your RNA-Seq analysis to yield more reliable results. If you have specific questions or scenarios you want to discuss, feel free to ask! Here are examples of dispersion plots suggesting potential data quality or fitting issues: 4.2.6 MOV10 Differential Expression Analysis: Exploring Dispersion Estimates Now, let’s explore the dispersion estimates for the MOV10 dataset: ## Plot dispersion estimates plotDispEsts(dds) Since we have a small sample size, for many genes we see quite a bit of shrinkage. Do you think our data are a good fit for the model? "],["negative-binomial-model-fitting.html", "Chapter 5 Negative Binomial model fitting 5.1 Generalized Linear Model fit for each gene 5.2 Shrunken log2 foldchanges (LFC) 5.3 Statistical test for LFC estimates: Wald test 5.4 MOV10 Differential Expression Analysis: Control versus Overexpression 5.5 Summarizing Results", " Chapter 5 Negative Binomial model fitting 5.1 Generalized Linear Model fit for each gene The final step in the DESeq2 workflow is fitting the Negative Binomial (NB) model for each gene and performing differential expression testing. This step is crucial for identifying genes that are significantly differentially expressed between experimental conditions. DESeq2 uses a Negative Binomial Generalized Linear Model (GLM) to estimate the counts for each gene. A GLM is a statistical method that models relationships between variables and is an extension of linear regression. It is suitable for handling non-normally distributed data, such as RNA-seq counts, which often exhibit overdispersion (variance &gt; mean). To fit the NB GLM, DESeq2 requires two key parameters: Size factor, which accounts for differences in sequencing depth across samples. Dispersion estimate, which measures variability in gene expression across replicates. The model incorporates the estimated dispersion and the design matrix specifying the experimental conditions and covariates. 5.1.1 Negative Binomial Model Formula DESeq2 models RNA-seq counts as follows: \\[ Y_{ij} \\sim \\text{NB}\\left(\\mu_{ij}, \\alpha_i\\right) \\] Where: \\(Y_{ij}\\) is the observed counts for gene \\(i\\) in sample \\(j\\) \\(\\mu_{ij}\\) is the expected normalized counts for gene \\(i\\) in sample \\(j\\) \\(\\alpha_i\\) is the dispersion parameter for gene \\(i\\), which has been estimated The expected mean \\(\\mu_{ij}\\) is modeled as: \\[ \\mu_{ij} = sizeFactor_{j} \\times q_{ij} \\] Where: \\(sizeFactor_{j}\\) normalizes for differences in sequencing depth across samples \\(q_{ij}\\) represents the true underlying expression level of gene \\(i\\) in sample \\(j\\), typically modeled as a function of covariates (such as experimental conditions). 5.1.2 Estimating Beta Coefficients Using the Design Matrix In DESeq2, beta coefficients (\\(\\beta\\)) are estimated using the design matrix, which captures the experimental conditions for each sample (e.g., control, treatment). These coefficients represent the log2 fold changes in gene expression between different conditions. The estimation process involves fitting a negative binomial generalized linear model (GLM) to the observed count data for each gene, where the expected mean expression \\(\\mu_{ij}\\) is modeled as a function of the design matrix \\(X_j\\) and the beta coefficients \\(\\beta_i\\). 5.1.3 Step-by-Step Process: Define the Design Matrix \\(X_j\\): The design matrix \\(X\\) includes the covariates (experimental conditions) for each sample. Each row of the matrix corresponds to a sample, and each column corresponds to a covariate (e.g., intercept, control, treatment). This matrix is generated using the model.matrix() function in R. X &lt;- model.matrix(~sampletype, data = meta) # OR X &lt;- model.matrix(design(dds), data = colData(dds)) Link Mean Expression to the Design Matrix: The expected mean expression for gene \\(i\\) in sample \\(j\\) is modeled as: \\[ \\log_2(\\mu_{ij}) = \\beta_i X_j \\] Or equivalently: \\[ \\mu_{ij} = 2^{\\beta_i X_j} \\] Here: \\(X_j\\) is the row of the design matrix for sample \\(j\\) (it contains the covariates for that sample) \\(\\beta_i\\) is the vector of log2 fold changes (beta coefficients) for gene \\(i\\). Estimate the Beta Coefficients: “DESeq2 estimates the beta coefficients by fitting a negative binomial GLM to the data using Maximum Likelihood Estimation (MLE). DESeq2 substitutes the mean (\\(\\mu_{ij}\\)) with \\(2^{\\beta_i X_j}\\) in the negative binomial model, using MLE to predict expected counts based on experimental covariates and estimate gene expression changes while controlling for design factors. The model is fit using the DESeq() function in R, which carries out the entire estimation process: dds &lt;- DESeq(dds) Extract the Beta Coefficients: Once the model is fitted, the estimated beta coefficients (log2 fold changes) for each gene can be extracted using the coef() function: beta_coefficients &lt;- coef(dds) This gives a matrix of estimated beta coefficients, where each row corresponds to a gene and each column corresponds to a covariate in the design matrix. 5.1.4 Example: For example, if the design matrix includes an intercept (control) and two conditions (MOV10 knockdown and MOV10 overexpression), the beta coefficients \\(\\beta_i\\) for gene \\(i\\) would represent: \\(\\beta_{i1}\\): the log2 fold change for the control group (intercept) \\(\\beta_{i2}\\): the log2 fold change for the MOV10 knockdown group \\(\\beta_{i3}\\): the log2 fold change for the MOV10 overexpression group. 5.1.5 Calculation: To calculate the fitted (expected) log2 counts for gene \\(i\\) in sample \\(j\\), you can take the dot product of the row of the design matrix \\(X_j\\) for that sample and the beta coefficients \\(\\beta_i\\) for that gene: \\[ \\log_2(\\mu_{ij}) = \\beta_i X_j = \\beta_{i1} X_{j1} + \\beta_{i2} X_{j2} + \\dots + \\beta_{iP} X_{jP} \\] Where: \\(P\\) is the number of covariates in the design matrix The expected mean \\(\\mu_{ij}\\) on the original count scale is obtained by exponentiating the log2-scale fitted values: \\[ \\mu_{ij} = 2^{\\beta_i X_j} \\] Exercise points = +1 In the DESeq2 workflow, what is the purpose of the design matrix in the context of fitting the Negative Binomial model for each gene? Ans: 5.1.6 Matrix Multiplication Form: If you want to calculate the fitted values for all genes and samples at once, you can express the model as a matrix multiplication: \\[ \\log_2(\\mu) = \\beta X^T \\] This computes the expected log2 counts for all genes across all samples. In R, you can calculate the fitted log2 counts for all genes and samples using: log2_fitted &lt;- beta_coefficients %*% t(X) This step multiplies the beta coefficients matrix by the transpose of the design matrix to compute the fitted log2 counts. 5.1.7 Log2 Fold Change and Adjustments The \\(\\beta\\) coefficents are the estimates for the log2 fold changes for each sample group. However, log2 fold changes are inherently noisier when counts are low due to the large dispersion we observe with low read counts. To avoid this, the log2 fold changes calculated by the model need to be adjusted. 5.2 Shrunken log2 foldchanges (LFC) To generate more accurate LFC estimates, DESeq2 allows for the shrinkage of the LFC estimates toward zero when the information for a gene is low, which could include: Low counts High dispersion values As with the shrinkage of dispersion estimates, LFC shrinkage uses information from all genes to generate more accurate estimates. Specifically, the distribution of LFC estimates for all genes is used (as a prior) to shrink the LFC estimates of genes with little information or high dispersion toward more likely (lower) LFC estimates. Illustration taken from the DESeq2 paper. For example, in the figure above, the green gene and purple gene have the same mean values for the two sample groups (C57BL/6J and DBA/2J), but the green gene has little variation while the purple gene has high levels of variation. For the green gene with low variation, the unshrunken LFC estimate (vertex of the green solid line) is very similar to the shrunken LFC estimate (vertex of the green dotted line), but the LFC estimates for the purple gene are quite different due to the high dispersion. So even though two genes can have similar normalized count values, they can have differing degrees of LFC shrinkage. Notice the LFC estimates are shrunken toward the prior (black solid line). Generating Shrunken LFC Estimates To generate the shrunken log2 fold change estimates, you have to run an additional step on your results object (that we will create below) with the function lfcShrink() 5.2.1 Hypothesis Testing In DESeq2, hypothesis testing evaluates whether changes in gene expression between conditions are statistically significant. The null hypothesis assumes no differential expression between groups, meaning the log2 fold change is zero (\\(LFC = 0\\)). 5.3 Statistical test for LFC estimates: Wald test In DESeq2, the Wald test is the default used for hypothesis testing when comparing two groups. The Wald test is a test usually performed on the LFC estimates. DESeq2 implements the Wald test by: Taking the LFC and dividing it by its standard error, resulting in a z-statistic The z-statistic is compared to a standard normal distribution, and a p-value is computed reporting the probability that a z-statistic at least as extreme as the observed value would be selected at random If the p-value is small we reject the null hypothesis (LFC = 0) and state that there is evidence against the null (i.e. the gene is differentially expressed). 5.4 MOV10 Differential Expression Analysis: Control versus Overexpression We have three sample classes so we can make three possible pairwise comparisons: Control vs. Mov10 overexpression Control vs. Mov10 knockdown Mov10 knockdown vs. Mov10 overexpression We are really only interested in #1 and #2 from above. Using the design formula we provided ~ sampletype, indicating that this is our main factor of interest. 5.4.1 Creating Contrasts for Hypothesis Testing In DESeq2, contrasts specify which groups to compare for differential expression testing. You can define contrasts in two ways: Default Comparison: DESeq2 automatically uses the alphabetically first level of the factor as the baseline. Manual Specification: You can manually specify the comparison using the contrast argument in the results() function. The contrast argument takes a vector of three elements. The first element is the name of the factor (design). The second and third elements listed in the contrast are the names of the numerator and denominator level for the fold change, respectively. Building the Results Table To build the results table, we use the results() function. You can specify the contrast to be tested using the contrast argument. In this example, we’ll save the unshrunken and shrunken results of Control vs. Mov10 overexpression to different variables. We’ll also set the alpha to 0.05, which is more stringent than the default value of 0.1. # define contrasts contrast_oe &lt;- c(&quot;sampletype&quot;, &quot;MOV10_overexpression&quot;, &quot;control&quot;) # extract results table res_tableOE_unshrunken &lt;- results(dds, contrast = contrast_oe, alpha = 0.05) resultsNames(dds) ## [1] &quot;Intercept&quot; ## [2] &quot;sampletype_MOV10_knockdown_vs_control&quot; ## [3] &quot;sampletype_MOV10_overexpression_vs_control&quot; # shrink log2 fold changes res_tableOE &lt;- lfcShrink(dds = dds, coef = &quot;sampletype_MOV10_overexpression_vs_control&quot;, res = res_tableOE_unshrunken) # save the results for future use saveRDS(res_tableOE, file = &quot;data/res_tableOE.RDS&quot;) The order of the names determines the direction of fold change that is reported. The name provided in the second element is the level that is used as baseline. So for example, if we observe a log2 fold change of -2 this would mean the gene expression is lower in Mov10_oe relative to the control. 5.4.2 MA Plot A plot that can be useful to exploring our results is the MA plot. The MA plot shows the mean of the normalized counts versus the log2 foldchanges for all genes tested. The genes that are significantly DE are colored to be easily identified. This is also a great way to illustrate the effect of LFC shrinkage. The DESeq2 package offers a simple function to generate an MA plot. Shrunken &amp; Unshrunken Results: par(mfrow = c(1, 2)) plotMA(res_tableOE_unshrunken, ylim = c(-2, 2)) abline(v = 10, col = &quot;red&quot;, lwd = 2) # Shrunken results: plotMA(res_tableOE, ylim = c(-2, 2)) abline(v = 10, col = &quot;red&quot;, lwd = 2) MOV10 DE Analysis: Exploring the Results The results table in DESeq2 looks similar to a data.frame and can be treated like one for accessing or subsetting data. However, it is stored as a DESeqResults object, which is important to keep in mind when working with visualization tools. class(res_tableOE) ## [1] &quot;DESeqResults&quot; ## attr(,&quot;package&quot;) ## [1] &quot;DESeq2&quot; Let’s go through some of the columns in the results table to get a better idea of what we are looking at. To extract information regarding the meaning of each column we can use mcols(): mcols(res_tableOE, use.names = T) ## DataFrame with 5 rows and 2 columns ## type description ## &lt;character&gt; &lt;character&gt; ## baseMean intermediate mean of normalized c.. ## log2FoldChange results log2 fold change (MA.. ## lfcSE results posterior SD: sample.. ## pvalue results Wald test p-value: s.. ## padj results BH adjusted p-values Now let’s take a look at what information is stored in the results: head(res_tableOE) ## log2 fold change (MAP): sampletype MOV10_overexpression vs control ## Wald test p-value: sampletype MOV10 overexpression vs control ## DataFrame with 6 rows and 5 columns ## baseMean log2FoldChange lfcSE pvalue padj ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1/2-SBSRNA4 45.652040 0.16820235 0.209100 0.1610752 0.2655661 ## A1BG 61.093102 0.13645896 0.176779 0.2401909 0.3603094 ## A1BG-AS1 175.665807 -0.04046122 0.116928 0.6789312 0.7748342 ## A1CF 0.237692 0.00626747 0.210057 0.7945932 NA ## A2LD1 89.617985 0.29017719 0.195395 0.0333343 0.0741149 ## A2M 5.860084 -0.09619722 0.233561 0.1057823 0.1900466 names(res_tableOE) ## [1] &quot;baseMean&quot; &quot;log2FoldChange&quot; &quot;lfcSE&quot; &quot;pvalue&quot; ## [5] &quot;padj&quot; Interpreting p-values Set to NA In some cases, p-values or adjusted p-values may be set to NA for a gene. This happens in three scenarios: Zero counts: If all samples have zero counts for a gene, its baseMean will be zero, and the log2 fold change, p-value, and adjusted p-value will all be set to NA. Outliers: If a gene has an extreme count outlier, its p-values will be set to NA. These outliers are detected using Cook’s distance. Low counts: If a gene is filtered out by independent filtering for having a low mean normalized count, only the adjusted p-value will be set to NA. 5.4.3 Multiple Testing Correction When testing many genes, using raw p-values increases the chance of false positives (genes appearing significant by chance). If we used the p-value directly from the Wald test with a significance cut-off of p &lt; 0.05, that means there is a 5% chance it is a false positives. Each p-value is the result of a single test (single gene). The more genes we test, the more we inflate the false positive rate. This issue is the known as the multiple testing problem. FFor example, if we test 20,000 genes for differential expression, at p &lt; 0.05 we would expect to find 1,000 genes by chance. If we found 3000 genes to be differentially expressed total, 150 of our genes are false positives. We would not want to sift through our “significant” genes to identify which ones are true positives. DESeq2 addresses this by removing genes with low counts or outliers before testing and by applying the Benjamini-Hochberg (BH) method to control the false discovery rate (FDR). 5.4.4 Benjamini-Hochberg Adjustment The BH-adjusted p-value is calculated as: Sort p-values from smallest to largest. Assign ranks to each p-value \\(p_i\\). Compute the adjusted p-value: \\[p_{i}^{adj} = p_{i} \\times \\frac{m}{i}\\] Where: \\(p_{i}\\) is the raw p-value \\(m\\) is the total number of genes tested \\(i\\) is the rank of the p-value. Adjusted p-values are compared to a significance threshold (e.g., 0.05) to identify significant genes. The Bonferroni method, another correction, is more conservative and less commonly used due to a higher risk of false negatives. In most cases, we should use the adjusted p-values (BH-corrected) to identify significant genes. 5.4.5 MOV10 DE Analysis: Control vs. Knockdown After examining the overexpression results, let’s move on to the comparison between Control vs. Knockdown. We’ll use contrasts in the results() function to extract the results table and store it in the res_tableKD variable. You can also use coef to specify the contrast directly in the lfcShrink() function. # define contrast contrast_kd &lt;- c(&quot;sampletype&quot;, &quot;MOV10_knockdown&quot;, &quot;control&quot;) # extract results table res_tableKD_unshrunken &lt;- results(dds, contrast = contrast_kd, alpha = 0.05) resultsNames(dds) ## [1] &quot;Intercept&quot; ## [2] &quot;sampletype_MOV10_knockdown_vs_control&quot; ## [3] &quot;sampletype_MOV10_overexpression_vs_control&quot; # use the `coef` argument to specify the contrast directly res_tableKD &lt;- lfcShrink(dds, coef = 2, res = res_tableKD_unshrunken) ## Save results for future use saveRDS(res_tableKD, file = &quot;data/res_tableKD.RDS&quot;) 5.5 Summarizing Results To summarize the results, DESeq2 offers the summary() function, which conveniently reports the number of genes that are significantly differentially expressed at a specified threshold (default FDR &lt; 0.05). Note that, even though the output refers to p-values, it actually summarizes the results using adjusted p-values (padj/FDR). Let’s start by summarizing the results for the OE vs. control comparison: ## Summarize results summary(res_tableOE) ## ## out of 19748 with nonzero total read count ## adjusted p-value &lt; 0.05 ## LFC &gt; 0 (up) : 3103, 16% ## LFC &lt; 0 (down) : 3408, 17% ## outliers [1] : 0, 0% ## low counts [2] : 4171, 21% ## (mean count &lt; 5) ## [1] see &#39;cooksCutoff&#39; argument of ?results ## [2] see &#39;independentFiltering&#39; argument of ?results In addition to reporting the number of up- and down-regulated genes at the default significance threshold, this function also provides information on: Number of genes tested (genes with non-zero total read count) Number of genes excluded from multiple test correction due to low mean counts 5.5.1 Extracting Significant Differentially Expressed Genes In some cases, using only the FDR threshold doesn’t sufficiently reduce the number of significant genes, making it difficult to extract biologically meaningful results. To increase stringency, we can apply an additional fold change threshold. Although the summary() function doesn’t include an argument for fold change thresholds, we can define our own criteria. Let’s start by setting the thresholds for both adjusted p-value (FDR &lt; 0.05) and log2 fold change (|log2FC| &gt; 0.58, corresponding to a 1.5-fold change): ### Set thresholds padj.cutoff &lt;- 0.05 lfc.cutoff &lt;- 0.58 Next, we’ll convert the results table to a tibble for easier subsetting: res_tableOE_tb &lt;- res_tableOE %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% as_tibble() Now, we can filter the table to retain only the genes that meet the significance and fold change criteria: sigOE &lt;- res_tableOE_tb %&gt;% dplyr::filter(padj &lt; padj.cutoff &amp; abs(log2FoldChange) &gt; lfc.cutoff) # Save the results for future use saveRDS(sigOE, &quot;data/sigOE.RDS&quot;) Exercise points = +3 How many genes are differentially expressed in the Overexpression vs. Control comparison based on the criteria we just defined? Does this reduce the number of significant genes compared to using only the FDR threshold? # Your code here Does this reduce our results? # Your code here 5.5.2 MOV10 Knockdown Analysis: Control vs. Knockdown Next, let’s perform the same analysis for the Control vs. Mov10 knockdown comparison. We’ll use the same thresholds for adjusted p-value (FDR &lt; 0.05) and log2 fold change (|log2FC| &gt; 0.58). res_tableKD_tb &lt;- res_tableKD %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% as_tibble() sigKD &lt;- res_tableKD_tb %&gt;% dplyr::filter(padj &lt; padj.cutoff &amp; abs(log2FoldChange) &gt; lfc.cutoff) # We&#39;ll save this object for use in the homework saveRDS(sigKD, &quot;data/sigKD.RDS&quot;) How many genes are differentially expressed in the Knockdown compared to Control? # Your code here With our subset of significant genes identified, we can now proceed to visualize the results and explore patterns of differential expression. ## Save all objects for later save.image() "],["visualizing-rna-seq-results.html", "Chapter 6 Visualizing RNA-seq results", " Chapter 6 Visualizing RNA-seq results During this lesson, we will get you started with some basic and more advanced visualization techniques to explore and interpret the results of your differential expression analysis. Let’s start by loading a few libraries: # load libraries library(tidyverse) library(ggplot2) library(ggrepel) library(RColorBrewer) library(DESeq2) library(pheatmap) library(dplyr) We will be working with three different data objects we have already created in earlier lessons: Metadata for our samples (a dataframe): meta Normalized expression data for every gene in each of our samples (a matrix): normalized_counts Tibble versions of the DESeq2 results we generated in the last lesson: res_tableOE_tb and res_tableKD_tb Let’s create tibble objects from the meta and normalized_counts data frames before we start plotting. This will enable us to use the tidyverse functionality more easily. Check to make sure the column names of the normalized_counts matrix are the same as the row names of the meta data frame. If they are not, you will need to reorder the columns of normalized_counts to match the row names of meta. # Read in the metadata meta &lt;- read.table(&quot;data/Mov10_full_meta.txt&quot;, header = T, row.names = 1) # Create a tibble for meta data mov10_meta &lt;- meta %&gt;% rownames_to_column(var = &quot;samplename&quot;) %&gt;% as_tibble() # read in the normalized counts normalized_counts &lt;- read.delim(&quot;data/normalized_counts.txt&quot;, row.names = 1) all(mov10_meta$samplename == colnames(normalized_counts)) ## [1] TRUE # Create a tibble for normalized_counts normalized_counts &lt;- normalized_counts %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% as_tibble() 6.0.1 Plotting signicant DE genes One way to visualize results would be to simply plot the expression data for a handful of genes. We could do that by picking out specific genes of interest or selecting a range of genes. 6.0.1.1 Using DESeq2 plotCounts() to plot expression of a single gene To pick out a specific gene of interest to plot, for example Mov10, we can use the plotCounts() from DESeq2. plotCounts() is a function that allows us to plot the normalized counts for a single gene across all samples. plotCounts(dds, gene = &quot;MOV10&quot;, intgroup = &quot;sampletype&quot;) # We can also color the points by sample type sampletype = as.factor(mov10_meta$sampletype) library(RColorBrewer) display.brewer.all() col = brewer.pal(8, &quot;Dark2&quot;) palette(col) plotCounts(dds, gene = &quot;MOV10&quot;, intgroup = &quot;sampletype&quot;, col = as.numeric(sampletype), pch = 19) This function only allows for plotting the counts of a single gene at a time. 6.0.1.2 Using ggplot2 to plot expression of a single gene We can also use ggplot2 to plot the MOV10 counts. We can save the output of plotCounts() to a variable specifying the returnData=TRUE argument. This will save the normalized counts for the gene MOV10 to a data frame object. We can then use ggplot2 to plot the normalized counts for MOV10 across all samples. # Save `plotCounts()` to a data frame object d &lt;- plotCounts(dds, gene = &quot;MOV10&quot;, intgroup = &quot;sampletype&quot;, returnData = TRUE) # Plot using ggplot2 ggplot(d, aes(x = sampletype, y = count, color = sampletype)) + geom_point(position = position_jitter(w = 0.1, h = 0)) + geom_text_repel(aes(label = rownames(d))) + theme_bw() + ggtitle(&quot;MOV10&quot;) + theme(plot.title = element_text(hjust = 0.5)) Note that in the plot below (code above), we are using geom_text_repel() from the ggrepel package to label our individual points on the plot. 6.0.1.3 Using ggplot2 to plot multiple genes (e.g. top 20) Often it is helpful to check the expression of multiple genes of interest at the same time. This often first requires some data wrangling. We are going to plot the normalized count values for the top 20 differentially expressed genes (by padj values). To do this, we first need to determine the gene names of our top 20 genes by ordering our results and extracting the top 20 genes (by padj values): res_tableOE &lt;- readRDS(&quot;data/res_tableOE.RDS&quot;) res_tableOE_tb &lt;- res_tableOE %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% as_tibble() ## Order results by padj values top20_sigOE_genes &lt;- res_tableOE_tb %&gt;% arrange(padj) %&gt;% # Arrange rows by padj values pull(gene) %&gt;% # Extract character vector of ordered genes head(n = 20) # Extract the first 20 genes Then, we can extract the normalized count values for these top 20 genes: ## Normalized counts for top 20 significant genes top20_sigOE_norm &lt;- normalized_counts %&gt;% filter(gene %in% top20_sigOE_genes) Now that we have the normalized counts for each of the top 20 genes for all 8 samples, to plot using ggplot(), we need to pivot_longer top20_sigOE_norm from a wide format to a long format so the counts for all samples will be in a single column to allow us to give ggplot the one column with the values we want it to plot. The pivot_longer() function in the tidyr package will perform this operation and will output the normalized counts for all genes for Mov10_oe_1 listed in the first 20 rows, followed by the normalized counts for Mov10_oe_2 in the next 20 rows, so on and so forth. # Pivot the data frame pivoted_top20_sigOE &lt;- top20_sigOE_norm %&gt;% pivot_longer(colnames(top20_sigOE_norm)[2:9], names_to = &quot;samplename&quot;, values_to = &quot;normalized_counts&quot;) ## Check the column header in the &#39;pivoted&#39; data frame head(pivoted_top20_sigOE) ## [90m# A tibble: 6 × 3[39m ## gene samplename normalized_counts ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m1[39m ADAMTS1 Irrel_kd_1 [4m6[24m718. ## [90m2[39m ADAMTS1 Irrel_kd_2 [4m6[24m455. ## [90m3[39m ADAMTS1 Irrel_kd_3 [4m6[24m802. ## [90m4[39m ADAMTS1 Mov10_kd_2 [4m6[24m869. ## [90m5[39m ADAMTS1 Mov10_kd_3 [4m8[24m731. ## [90m6[39m ADAMTS1 Mov10_oe_1 [4m1[24m[4m3[24m252. Now, if we want our counts colored by sample group, then we need to combine the metadata information with the melted normalized counts data into the same data frame for input to ggplot(): inner_join(x,y) will merge 2 data frames by the colname in x that matches a column name in y in this case samplename column. pivoted_top20_sigOE &lt;- inner_join(mov10_meta, pivoted_top20_sigOE) Now that we have a data frame in a format that can be utilised by ggplot easily, let’s plot! ## plot using ggplot2 ggplot(pivoted_top20_sigOE) + geom_point(aes(x = gene, y = normalized_counts, color = sampletype)) + scale_y_log10() + xlab(&quot;Genes&quot;) + ylab(&quot;log10 Normalized Counts&quot;) + ggtitle(&quot;Top 20 Significant DE Genes&quot;) + theme_bw() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + theme(plot.title = element_text(hjust = 0.5)) 6.0.2 Heatmap We will plot a heatmap of the sigOE genes to visualize their expression across all samples using pheatmap(). sigOE = readRDS(&quot;data/sigOE.RDS&quot;) norm_OEsig &lt;- normalized_counts[, c(1, 2:4, 7:9)] %&gt;% filter(gene %in% sigOE$gene) %&gt;% data.frame() %&gt;% column_to_rownames(var = &quot;gene&quot;) Now let’s draw the heatmap using pheatmap. We can also add annotations to the heatmap to indicate the sample type. The annotation_col argument in pheatmap()requires a data frame with the same row names as the column names of the matrix used to generate the heatmap. ### Annotate our heatmap (optional) annotation &lt;- mov10_meta %&gt;% filter(samplename %in% colnames(norm_OEsig)) %&gt;% dplyr::select(samplename, sampletype) %&gt;% data.frame(row.names = &quot;samplename&quot;) annotation$sampletype = factor(annotation$sampletype) ### Set a color palette heat_colors &lt;- brewer.pal(6, &quot;YlOrRd&quot;) ### Set annotation colors ann_colors = list(sampletype = c(control = &quot;navy&quot;, MOV10_overexpression = &quot;green&quot;)) ### Run pheatmap pheatmap(norm_OEsig, annotation_colors = ann_colors, color = heat_colors, cluster_rows = T, show_rownames = F, annotation_col = annotation, border_color = NA, fontsize = 12, scale = &quot;row&quot;, fontsize_col = 12) NOTE: There are several additional arguments we have included in the function for aesthetics. One important one is scale=\"row\", in which Z-scores are plotted, rather than the actual normalized count value. 6.0.3 Volcano plots A commonly used plot in RNA-seq analysis is the volcano plot. in which you have the log transformed adjusted p-values plotted on the y-axis and log2 fold change values on the x-axis. To generate a volcano plot, we first need to have a column in our results data indicating whether or not the gene is considered differentially expressed based on p-adjusted values. ## create a column for thresholding in the results table res_tableOE_tb &lt;- res_tableOE_tb %&gt;% mutate(threshold_OE = padj &lt; 0.05 &amp; abs(log2FoldChange) &gt;= 0.58) Now we can start plotting. The geom_point object is most applicable, as this is essentially a scatter plot: ggplot(res_tableOE_tb) + geom_point(aes(x = log2FoldChange, y = -log10(padj), colour = threshold_OE)) + ggtitle(&quot;Mov10 overexpression&quot;) + xlab(&quot;log2 fold change&quot;) + ylab(&quot;-log10 adjusted p-value&quot;) + theme_bw() + theme(legend.position = &quot;none&quot;, plot.title = element_text(size = rel(1.5), hjust = 0.5), axis.title = element_text(size = rel(1.25))) What if we also wanted to know where the top 10 genes (lowest padj) in our DE list are located on this plot? We could label those dots with the gene name on the volcano plot using geom_text_repel(). First, we need to order the res_tableOE tibble by padj, and add an additional column to it, to include on those gene names we want to use to label the plot. ## Create a column to indicate which genes to label res_tableOE_tb &lt;- res_tableOE_tb %&gt;% arrange(padj) %&gt;% mutate(genelabels = &quot;&quot;) res_tableOE_tb$genelabels[1:10] &lt;- res_tableOE_tb$gene[1:10] head(res_tableOE_tb) ## [90m# A tibble: 6 × 8[39m ## gene baseMean log2FoldChange lfcSE pvalue padj threshold_OE ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;lgl&gt;[39m[23m ## [90m1[39m MOV10 [4m2[24m[4m1[24m682. 5.08 0.110 0 [90m [39m 0 [90m [39m TRUE ## [90m2[39m H1F0 [4m7[24m881. 1.55 0.056[4m6[24m 3.00[90me[39m[31m-166[39m 2.34[90me[39m[31m-162[39m TRUE ## [90m3[39m HIST1H1C [4m1[24m741. 1.52 0.070[4m6[24m 2.06[90me[39m[31m-104[39m 1.07[90me[39m[31m-100[39m TRUE ## [90m4[39m TXNIP [4m5[24m134. 1.42 0.069[4m7[24m 1.62[90me[39m[31m- 93[39m 6.33[90me[39m[31m- 90[39m TRUE ## [90m5[39m NEAT1 [4m2[24m[4m1[24m974. 0.916 0.046[4m7[24m 8.28[90me[39m[31m- 87[39m 2.58[90me[39m[31m- 83[39m TRUE ## [90m6[39m KLF10 [4m1[24m694. 1.23 0.065[4m2[24m 4.77[90me[39m[31m- 81[39m 1.24[90me[39m[31m- 77[39m TRUE ## [90m# ℹ 1 more variable: genelabels &lt;chr&gt;[39m Next, we plot it as before with an additiona layer for geom_text_repel() wherein we can specify the column of gene labels we just created. ggplot(res_tableOE_tb, aes(x = log2FoldChange, y = -log10(padj))) + geom_point(aes(colour = threshold_OE)) + geom_text_repel(aes(label = genelabels)) + ggtitle(&quot;Mov10 overexpression&quot;) + xlab(&quot;log2 fold change&quot;) + ylab(&quot;-log10 adjusted p-value&quot;) + theme_bw() + theme(legend.position = &quot;none&quot;, plot.title = element_text(size = rel(1.5), hjust = 0.5), axis.title = element_text(size = rel(1.25))) "],["summary-of-dge-workflow.html", "Chapter 7 Summary of DGE workflow", " Chapter 7 Summary of DGE workflow Homework: modify this file to analyze the MOV dataset, starting with Mov10_full_counts.txt in your data folder. Compare the “MOV10_knockdown” to the “control”. Include a heatmap and a volcano plot points = +10 ## Setup library(DESeq2) We have detailed the various steps in a differential expression analysis workflow, providing theory with example code. To provide a more succinct reference for the code needed to run a DGE analysis, we have summarized the steps in an analysis below: 7.0.1 1. Import data into dds object: # Check that the row names of the metadata equal the column names of the **raw # counts** data all(colnames(raw_counts) == rownames(metadata)) # Create DESeq2Dataset object dds &lt;- DESeqDataSetFromMatrix(countData = raw_counts, colData = metadata, design = ~condition) 7.0.2 2. Exploratory data analysis (PCA &amp; heirarchical clustering) - identifying outliers and sources of variation in the data: # Transform counts for data visualization rld &lt;- rlog(dds, blind = TRUE) # Plot PCA plotPCA(rld, intgroup = &quot;sampletype&quot;) # Extract the rlog matrix from the object rld_mat &lt;- assay(rld) # Compute pairwise correlation values rld_cor &lt;- cor(rld_mat) # Plot heatmap pheatmap(rld_cor) 7.0.3 3. Run DESeq2: # **Optional step** - Re-create DESeq2 dataset if the design formula has # changed after QC analysis in include other sources of variation dds &lt;- DESeqDataSetFromMatrix(countData = raw_counts, colData = metadata, design = ~condition) # Run DESeq2 differential expression analysis dds &lt;- DESeq(dds) # Output normalized counts to save as a file to access outside RStudio normalized_counts &lt;- counts(dds, normalized = TRUE) write.table(normalized_counts, file = &quot;data/normalized_counts.txt&quot;, sep = &quot;\\t&quot;, quote = F, col.names = NA) 7.0.4 4. Check the fit of the dispersion estimates: # Plot dispersion estimates plotDispEsts(dds) 7.0.5 5. Create contrasts to perform Wald testing on the shrunken log2 foldchanges between specific conditions: # Output results of Wald test for contrast contrast &lt;- c(&quot;condition&quot;, &quot;level_to_compare&quot;, &quot;base_level&quot;) res &lt;- results(dds, contrast = contrast) coef = resultsNames(dds) res_table &lt;- lfcShrink(dds, coef = coef[2], res = res, type = &quot;apeglm&quot;) 7.0.6 6. Output significant results: ### Set thresholds padj.cutoff &lt;- 0.05 lfc.cutoff &lt;- 0.58 ## change in expression of 1.5 # Turn the results object into a data frame res_df &lt;- res %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot;gene&quot;) # Subset the significant results sig_res &lt;- dplyr::filter(res_df, padj &lt; padj.cutoff &amp; abs(log2FoldChange) &gt; lfc.cutoff) 7.0.7 7. Visualize results: volcano plots, heatmaps, normalized counts plots of top genes, etc. 7.0.8 8. Make sure to output the versions of all tools used in the DE analysis: sessionInfo() ## R version 4.5.1 (2025-06-13) ## Platform: x86_64-apple-darwin20 ## Running under: macOS Sequoia 15.6 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/4.5-x86_64/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.5-x86_64/Resources/lib/libRlapack.dylib; LAPACK version 3.12.1 ## ## locale: ## [1] en_CA.UTF-8/en_CA.UTF-8/en_CA.UTF-8/C/en_CA.UTF-8/en_CA.UTF-8 ## ## time zone: America/Los_Angeles ## tzcode source: internal ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] ggrepel_0.9.6 pheatmap_1.0.13 ## [3] DESeq2_1.48.1 SummarizedExperiment_1.38.1 ## [5] Biobase_2.68.0 MatrixGenerics_1.20.0 ## [7] matrixStats_1.5.0 GenomicRanges_1.60.0 ## [9] GenomeInfoDb_1.44.2 IRanges_2.42.0 ## [11] S4Vectors_0.46.0 BiocGenerics_0.54.0 ## [13] generics_0.1.4 RColorBrewer_1.1-3 ## [15] lubridate_1.9.4 forcats_1.0.0 ## [17] stringr_1.5.1 dplyr_1.1.4 ## [19] purrr_1.1.0 readr_2.1.5 ## [21] tidyr_1.3.1 tibble_3.3.0 ## [23] ggplot2_3.5.2 tidyverse_2.0.0 ## ## loaded via a namespace (and not attached): ## [1] rstudioapi_0.17.1 jsonlite_2.0.0 magrittr_2.0.3 ## [4] ggtangle_0.0.7 farver_2.1.2 rmarkdown_2.29 ## [7] fs_1.6.6 vctrs_0.6.5 memoise_2.0.1 ## [10] ggtree_3.16.3 htmltools_0.5.8.1 S4Arrays_1.8.1 ## [13] SparseArray_1.8.1 gridGraphics_0.5-1 sass_0.4.10 ## [16] bslib_0.9.0 plyr_1.8.9 cachem_1.1.0 ## [19] igraph_2.1.4 lifecycle_1.0.4 pkgconfig_2.0.3 ## [22] Matrix_1.7-3 R6_2.6.1 fastmap_1.2.0 ## [25] gson_0.1.0 GenomeInfoDbData_1.2.14 digest_0.6.37 ## [28] numDeriv_2016.8-1.1 aplot_0.2.8 enrichplot_1.28.4 ## [31] colorspace_2.1-1 patchwork_1.3.1 AnnotationDbi_1.70.0 ## [34] RSQLite_2.4.3 labeling_0.4.3 timechange_0.3.0 ## [37] httr_1.4.7 abind_1.4-8 compiler_4.5.1 ## [40] bit64_4.6.0-1 withr_3.0.2 BiocParallel_1.42.1 ## [43] DBI_1.2.3 R.utils_2.13.0 MASS_7.3-65 ## [46] rappdirs_0.3.3 DelayedArray_0.34.1 tools_4.5.1 ## [49] ape_5.8-1 R.oo_1.27.1 glue_1.8.0 ## [52] nlme_3.1-168 GOSemSim_2.34.0 grid_4.5.1 ## [55] reshape2_1.4.4 fgsea_1.34.2 gtable_0.3.6 ## [58] tzdb_0.5.0 R.methodsS3_1.8.2 data.table_1.17.8 ## [61] hms_1.1.3 utf8_1.2.6 XVector_0.48.0 ## [64] pillar_1.11.0 yulab.utils_0.2.1 emdbook_1.3.14 ## [67] splines_4.5.1 treeio_1.32.0 lattice_0.22-7 ## [70] bit_4.6.0 tidyselect_1.2.1 GO.db_3.21.0 ## [73] locfit_1.5-9.12 Biostrings_2.76.0 knitr_1.50 ## [76] bookdown_0.44 xfun_0.53 stringi_1.8.7 ## [79] UCSC.utils_1.4.0 lazyeval_0.2.2 ggfun_0.2.0 ## [82] yaml_2.3.10 evaluate_1.0.4 codetools_0.2-20 ## [85] bbmle_1.0.25.1 qvalue_2.40.0 ggplotify_0.1.2 ## [88] cli_3.6.5 jquerylib_0.1.4 Rcpp_1.1.0 ## [91] coda_0.19-4.1 png_0.1-8 bdsmatrix_1.3-7 ## [94] parallel_4.5.1 blob_1.2.4 clusterProfiler_4.16.0 ## [97] DOSE_4.2.0 mvtnorm_1.3-3 apeglm_1.30.0 ## [100] tidytree_0.4.6 scales_1.4.0 crayon_1.5.3 ## [103] rlang_1.1.6 cowplot_1.2.0 fastmatch_1.1-6 ## [106] KEGGREST_1.48.1 formatR_1.14 "],["functional-analysis-of-rnaseq-data.html", "Chapter 8 Functional analysis of RNAseq data", " Chapter 8 Functional analysis of RNAseq data 8.0.1 Ontology and GO Terms Ontology: An ontology is a representation of something we know about. Ontologies consist of representations of things that are detectable or directly observable and the relationships between those things. The Gene Ontology (GO) project provides an ontology of defined terms representing gene product properties. These terms are connected to each other via formally defined relationships, allowing for consistent annotation and analysis of gene functions across different species and research areas. 8.0.2 GO Terms (Gene Ontology Terms) The GO terms describe three aspects of gene products: Biological Process: Refers to the biological objectives achieved by gene products, such as “cell division” or “response to stress.” Molecular Function: Describes the biochemical activities at the molecular level, such as “enzyme activity” or “DNA binding.” Cellular Component: Indicates where gene products are located within the cell, like “nucleus” or “mitochondrion.” 8.0.3 GO Enrichment Methods GO enrichment methods help interpret differentially expressed gene lists from RNA-Seq data and include the following: Overrepresentation Analysis (ORA): ORA assesses whether specific GO terms are over-represented in a gene list compared to the background set of genes (e.g., all genes in the genome). Over-represented GO terms indicate biological functions or processes that are significantly associated with the genes of interest. ` Hypergeometric Test: The hypergeometric test in GO enrichment analysis is used to determine whether a set of genes is enriched for specific GO terms compared to the background set of genes. The test calculates the probability of observing the overlap between the query gene set and the gene set associated with a particular GO term, given the total number of genes in the dataset and the number of genes in the background set. The formula for the cumulative probability of observing at most \\(q\\) successes (the lower-tail probability) in a sample of size \\(k\\) from a population with \\(m\\) successes and \\(N - m\\) failures is: \\[ P(X \\leq q) = \\sum_{i=0}^{q} \\frac{\\binom{m}{i} \\binom{N - m}{k - i}}{\\binom{N}{k}} \\] Where: q: The number of genes in your list of interest that are annotated with a specific GO term (e.g., genes in your differential expression results that are associated with “cell cycle regulation”). m: The total number of genes in the background set (e.g., all genes in the genome) that are annotated with the specific GO term (e.g., all genes associated with “cell cycle regulation” in the entire dataset or genome). N: The total number of genes in the background set. k: The total number of genes in your gene list of interest 8.0.4 Example Suppose:your background population has \\(N = 20,000\\) genes (e.g., the entire genome). Out of these, \\(m = 500\\) genes are associated with a specific GO term (e.g., “cell cycle regulation”). You have a list of \\(k = 1000\\) genes of interest. In this list, \\(q = 30\\) genes are associated with the “cell cycle regulation” GO term. # Define parameters N &lt;- 20000 # Total genes in the background (population) m &lt;- 500 # Total genes associated with the GO term in the background k &lt;- 1000 # Sample size (genes in your list) q &lt;- 50 # Observed number of successes (overlap with GO term) # Perform the hypergeometric test (upper-tail probability) p_value &lt;- phyper(q - 1, m, N - m, k, lower.tail = FALSE) p_value ## [1] 2.551199e-06 Gene Set Enrichment Analysis (GSEA): Instead of only considering genes above a certain threshold (e.g., differentially expressed genes), GSEA looks at the entire ranked list of genes (e.g., ranked by their expression levels) and checks whether genes associated with a certain GO term are statistically over-represented at the top or bottom of a ranked gene list, indicating coordinated changes in gene expression. Here’s how GSEA works: Gene Ranking: Genes are ranked based on a metric that reflects their differential expression, such as log2FoldChange. Enrichment Score (ES): GSEA calculates an Enrichment Score (ES) for each gene set by walking down the ranked list, increasing the score when a gene belongs to the set and decreasing it otherwise. A positive ES suggests upregulation, while a negative ES suggests downregulation of the gene set. Example: The GSEA enrichment plot provides a graphical view of the enrichment score for a gene set: - The top portion of the plot shows the running ES for the gene set as the analysis walks down the ranked list. The score at the peak of the plot (the score furthest from 0.0) is the ES for the gene set. The middle portion of the plot shows where the members of the gene set appear in the ranked list of genes. The leading edge subset of a gene set is the subset of members that contribute most to the ES. The bottom portion of the plot shows the value of the ranking metric (such as log2FoldChange) as you move down the list of ranked genes. 8.0.5 Over-representation Analysis (ORA) using clusterProfiler ## Load required libraries library(org.Hs.eg.db) library(clusterProfiler) library(tidyverse) library(enrichplot) library(fgsea) library(igraph) library(ggraph) library(visNetwork) library(GO.db) library(GOSemSim) library(GOenrichment) library(tidyr) 8.0.5.1 Running clusterProfiler: we first need to load the results of the differential expression analysis. res_tableOE = readRDS(&quot;data/res_tableOE.RDS&quot;) res_tableOE_tb &lt;- res_tableOE %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% dplyr::filter(!is.na(log2FoldChange)) %&gt;% as_tibble() To perform the over-representation analysis, we need a list of background genes and a list of significant genes: ## background set of genes allOE_genes &lt;- res_tableOE_tb$gene sigOE = dplyr::filter(res_tableOE_tb, padj &lt; 0.05) ## significant genes sigOE_genes = sigOE$gene TheenrichGO() function performs the ORA for the significant genes of interest (sigOE_genes) compared to the background gene list (allOE_genes) and returns the enriched GO terms and their associated p-values. ## Run GO enrichment analysis ego &lt;- enrichGO(gene = sigOE_genes, universe = allOE_genes, keyType = &quot;SYMBOL&quot;, OrgDb = org.Hs.eg.db, minGSSize = 20, maxGSSize = 300, ont = &quot;BP&quot;, pAdjustMethod = &quot;BH&quot;, qvalueCutoff = 0.05, readable = TRUE) We can extract the gene lists associated with each enriched GO term from the ego object to create edges between terms based on shared genes. # Extract the result as a data frame enrich_df &lt;- as.data.frame(ego) names(enrich_df) ## [1] &quot;ID&quot; &quot;Description&quot; &quot;GeneRatio&quot; &quot;BgRatio&quot; ## [5] &quot;RichFactor&quot; &quot;FoldEnrichment&quot; &quot;zScore&quot; &quot;pvalue&quot; ## [9] &quot;p.adjust&quot; &quot;qvalue&quot; &quot;geneID&quot; &quot;Count&quot; head(enrich_df) ## ID ## GO:0006403 GO:0006403 ## GO:0042254 GO:0042254 ## GO:0051168 GO:0051168 ## GO:0043484 GO:0043484 ## GO:0000375 GO:0000375 ## GO:0000377 GO:0000377 ## Description ## GO:0006403 RNA localization ## GO:0042254 ribosome biogenesis ## GO:0051168 nuclear export ## GO:0043484 regulation of RNA splicing ## GO:0000375 RNA splicing, via transesterification reactions ## GO:0000377 RNA splicing, via transesterification reactions with bulged adenosine as nucleophile ## GeneRatio BgRatio RichFactor FoldEnrichment zScore pvalue ## GO:0006403 111/5296 189/14554 0.5873016 1.613970 6.425652 2.818880e-10 ## GO:0042254 152/5296 278/14554 0.5467626 1.502565 6.398863 2.833757e-10 ## GO:0051168 94/5296 156/14554 0.6025641 1.655914 6.229446 9.953107e-10 ## GO:0043484 102/5296 174/14554 0.5862069 1.610962 6.131985 1.701497e-09 ## GO:0000375 151/5296 284/14554 0.5316901 1.461144 5.935747 4.382494e-09 ## GO:0000377 149/5296 280/14554 0.5321429 1.462388 5.908870 5.137522e-09 ## p.adjust qvalue ## GO:0006403 5.450732e-07 4.644379e-07 ## GO:0042254 5.450732e-07 4.644379e-07 ## GO:0051168 1.276320e-06 1.087508e-06 ## GO:0043484 1.636414e-06 1.394332e-06 ## GO:0000375 2.823435e-06 2.405751e-06 ## GO:0000377 2.823435e-06 2.405751e-06 ## geneID ## GO:0006403 ALKBH5/ALYREF/ARC/ATR/ATXN2/BICD1/CAPRIN1/CASC3/CCT2/CCT3/CCT5/CCT6A/CCT7/CETN2/CETN3/CHTOP/DCP2/DDX19A/DDX39A/DHX9/DKC1/EIF4A3/ENY2/EXOSC10/FBL/FMR1/FUBP3/FXR2/FYTTD1/GLE1/HNRNPU/HSF1/IGF2BP1/IGF2BP2/KHDRBS1/KHSRP/KPNB1/MCM3AP/MVP/NCBP1/NEAT1/NHP2/NOL6/NOP10/NSUN2/NUP107/NUP133/NUP188/NUP205/NUP210/NUP214/NUP50/NUP54/NUP85/NUP88/NUP93/NUP98/NUTF2/NXF1/NXF3/NXT1/NXT2/PABPN1/PARN/PEG10/PHAX/PIH1D1/POLDIP3/POM121/POM121C/POM121L2/PRPF6/QKI/RAE1/RAN/RBM15B/RBM33/RBM8A/RFTN1/RUVBL1/RUVBL2/SARNP/SEC13/SEH1L/SENP2/SETD2/SHQ1/SIDT2/SLBP/SMG5/SMG6/SMG7/SNUPN/SRSF3/SRSF7/STAU1/SUPT6H/TGFBR2/THOC1/THOC2/THOC6/THOC7/TOMM20/UPF1/XPO1/XPO5/YBX1/ZC3H11A/ZFP36/ZFP36L1/ZNF385A ## GO:0042254 AATF/ABT1/BMS1/BRIX1/BYSL/C1QBP/CHD7/CUL4A/CUL4B/DDX18/DDX21/DDX27/DDX28/DDX47/DDX49/DDX51/DDX54/DDX56/DHX30/DHX37/DKC1/DNTTIP2/EBNA1BP2/EIF1AX/EIF2A/EIF4A3/EIF5/EIF5B/EIF6/EMG1/ERAL1/ERCC2/EXOSC10/EXOSC3/EXOSC5/EXOSC6/EXOSC9/FAU/FBL/FBLL1/FCF1/FRG1/FTSJ3/GEMIN4/GLUL/GNL3L/GRWD1/GTPBP10/HEATR1/IMP3/IMP4/ISG20L2/KRI1/LSG1/LSM6/LTV1/MAK16/MCAT/MDN1/MPHOSPH10/MRPS2/MRPS7/MRTO4/MYBBP1A/NAT10/NGDN/NGRN/NHP2/NLE1/NMD3/NOC2L/NOC4L/NOL10/NOL11/NOL6/NOL8/NOL9/NOLC1/NOP10/NOP14/NOP16/NOP2/NSUN5/NUDT16/NUP88/PA2G4/PDCD11/PELP1/PES1/PIH1D1/POP4/PPAN/PWP1/PWP2/RAN/RBM10/REXO1/REXO4/RIOK3/RPL24/RPL26/RPL26L1/RPL7L1/RPP30/RPP40/RPS15/RPS15A/RPS19BP1/RPS23/RPS27/RPS27A/RPS27L/RPS3A/RPSA/RPUSD1/RPUSD4/RRP1/RRP15/RRP1B/RRP36/RRP7A/RRP9/RRS1/RSL24D1/SBDS/SDAD1/SIRT7/SRFBP1/SURF6/SUV39H1/TFB1M/TRMT112/TRMT2B/TSR1/TSR2/URB1/URB2/UTP14A/UTP15/UTP18/UTP20/UTP3/WDR18/WDR43/WDR46/WDR55/WDR74/XPO1/XRCC5/XRN2/YTHDF2/ZNF622 ## GO:0051168 ADAR/AHCYL1/ALKBH5/ALYREF/ANP32B/BAG3/CASC3/CDK5/CHTOP/CSE1L/DDX19A/DDX39A/DHX9/EIF4A3/EIF6/EMD/ENY2/FMR1/FYTTD1/GAS6/GLE1/KHDRBS1/LSG1/LTV1/MCM3AP/MDM2/MDN1/NCBP1/NEAT1/NEMF/NMD3/NOL6/NSUN2/NUP107/NUP133/NUP188/NUP214/NUP85/NUP88/NUP93/NUP98/NUTF2/NXF1/NXF3/NXT1/NXT2/PABPN1/PARK7/PHAX/PKD1/POLDIP3/POM121/POM121C/POM121L2/PPM1A/PRKACA/PTPN11/RAE1/RAN/RANBP3/RANBP3L/RANGAP1/RAPGEF3/RBM10/RBM15B/RBM22/RBM33/RBM8A/RPS15/SARNP/SDAD1/SETD2/SFN/SIRT6/SIRT7/SMG5/SMG6/SMG7/SRSF3/SUPT6H/TGFB1/THOC1/THOC2/THOC6/THOC7/UBE2I/UPF1/XPO1/XPO4/XPO5/XPO6/XPO7/YWHAE/ZC3H11A ## GO:0043484 ACIN1/AHNAK/AHNAK2/ARGLU1/ATXN7L3/C1QBP/CCNL1/CCNL2/CELF1/CELF2/CELF3/CELF4/CIRBP/CLK1/CLNS1A/DAZAP1/DDX5/ENY2/ERN1/ESRP1/EXOSC10/FAM50A/FASTK/FMR1/FUS/GRSF1/HNRNPF/HNRNPH2/HNRNPK/HNRNPL/HNRNPU/HOXB-AS3/HSPA1A/KAT2A/KHDRBS1/KHDRBS3/LARP7/MBNL1/MBNL2/MBNL3/NCBP1/NCL/NOVA1/NUP98/PIK3R1/POLR2A/PQBP1/PRDX6/PRMT5/PRPF19/PTBP1/PTBP2/PUF60/QKI/RBFOX2/RBM10/RBM11/RBM12B/RBM15/RBM15B/RBM22/RBM23/RBM24/RBM3/RBM38/RBM39/RBM4/RBM42/RBM8A/RBMX/RBPMS/RBPMS2/RNPS1/RPS26/RRP1B/SF1/SF3B3/SFSWAP/SLC38A2/SMU1/SNRNP70/SRPK1/SRPK2/SRSF3/SRSF6/SRSF7/SRSF9/SUPT3H/TADA2B/TADA3/TAF5L/TAF6L/TIA1/TMBIM6/TRRAP/U2AF2/UPF1/USP22/WDR77/ZBTB7A/ZNF326/ZNF638 ## GO:0000375 ACIN1/ARGLU1/C1QBP/C9orf78/CASC3/CD2BP2/CELF1/CELF2/CELF3/CELF4/CIRBP/CLNS1A/COIL/CTNNBL1/CWC15/CWF19L1/DAZAP1/DBR1/DDX1/DDX23/DDX39A/DDX42/DDX5/DHX15/DHX16/DHX38/DHX40/DHX9/EFTUD2/EIF4A3/EXOSC10/FMR1/FRG1/GCFC2/GEMIN4/GEMIN5/GEMIN7/GPKOW/HNRNPA3/HNRNPF/HNRNPK/HNRNPL/HNRNPM/HNRNPR/HNRNPU/HNRNPUL1/HSPA8/HTATSF1/IK/ILF3/KHDRBS1/KHDRBS3/KHSRP/LARP7/LSM2/LSM3/LSM4/LSM5/LSM6/LSM7/LUC7L2/LUC7L3/METTL3/MPHOSPH10/NCBP1/NCL/NOVA1/NUP98/PABPC1/PLRG1/PNN/PPIL1/PQBP1/PRDX6/PRMT5/PRMT7/PRPF19/PRPF3/PRPF38A/PRPF39/PRPF4/PRPF40B/PRPF6/PRPF8/PTBP1/PTBP2/PUF60/QKI/RALY/RBFOX2/RBM10/RBM11/RBM15/RBM15B/RBM17/RBM22/RBM23/RBM24/RBM3/RBM39/RBM4/RBM42/RBM8A/RBMX/RBPMS/RBPMS2/RNF113A/RNPC3/RNPS1/SART3/SF1/SF3A1/SF3A3/SF3B1/SF3B2/SF3B3/SF3B4/SFPQ/SFSWAP/SMU1/SNRNP200/SNRNP25/SNRNP27/SNRNP40/SNRNP70/SNRPB/SNRPC/SNRPD1/SNRPD2/SNRPD3/SRPK1/SRPK2/SRSF3/SRSF6/SRSF7/SRSF9/STRAP/SYNCRIP/TFIP11/TIA1/TSSC4/TXNL4B/U2AF1/U2AF2/UBL5/UPF1/USP39/USP4/WDR77/ZBTB7A/ZMAT2 ## GO:0000377 ACIN1/ARGLU1/C1QBP/C9orf78/CASC3/CD2BP2/CELF1/CELF2/CELF3/CELF4/CIRBP/CLNS1A/COIL/CTNNBL1/CWC15/CWF19L1/DAZAP1/DBR1/DDX1/DDX23/DDX39A/DDX42/DDX5/DHX15/DHX16/DHX38/DHX40/DHX9/EFTUD2/EIF4A3/EXOSC10/FMR1/FRG1/GCFC2/GEMIN4/GEMIN5/GEMIN7/GPKOW/HNRNPA3/HNRNPF/HNRNPK/HNRNPL/HNRNPM/HNRNPR/HNRNPU/HNRNPUL1/HSPA8/HTATSF1/IK/ILF3/KHDRBS1/KHDRBS3/LARP7/LSM2/LSM3/LSM4/LSM5/LSM6/LSM7/LUC7L2/LUC7L3/METTL3/NCBP1/NCL/NOVA1/NUP98/PABPC1/PLRG1/PNN/PPIL1/PQBP1/PRDX6/PRMT5/PRMT7/PRPF19/PRPF3/PRPF38A/PRPF39/PRPF4/PRPF40B/PRPF6/PRPF8/PTBP1/PTBP2/PUF60/QKI/RALY/RBFOX2/RBM10/RBM11/RBM15/RBM15B/RBM17/RBM22/RBM23/RBM24/RBM3/RBM39/RBM4/RBM42/RBM8A/RBMX/RBPMS/RBPMS2/RNF113A/RNPC3/RNPS1/SART3/SF1/SF3A1/SF3A3/SF3B1/SF3B2/SF3B3/SF3B4/SFPQ/SFSWAP/SMU1/SNRNP200/SNRNP25/SNRNP27/SNRNP40/SNRNP70/SNRPB/SNRPC/SNRPD1/SNRPD2/SNRPD3/SRPK1/SRPK2/SRSF3/SRSF6/SRSF7/SRSF9/STRAP/SYNCRIP/TFIP11/TIA1/TSSC4/TXNL4B/U2AF1/U2AF2/UBL5/UPF1/USP39/USP4/WDR77/ZBTB7A/ZMAT2 ## Count ## GO:0006403 111 ## GO:0042254 152 ## GO:0051168 94 ## GO:0043484 102 ## GO:0000375 151 ## GO:0000377 149 # GO term IDs term_ids &lt;- enrich_df$ID # Split gene lists by &#39;/&#39; and assign term IDs as names gene_lists &lt;- strsplit(enrich_df$geneID, &quot;/&quot;) # Assign term IDs as names names(gene_lists) &lt;- term_ids Using the gene lists associated with each GO term, we can create edges between terms based on the shared genes. # Load GO data for semantic similarity calculation go_data &lt;- GOSemSim::godata(OrgDb = &quot;org.Hs.eg.db&quot;, ont = &quot;BP&quot;, keytype = &quot;SYMBOL&quot;, computeIC = TRUE) # Compute semantic similarity similarity_matrix &lt;- GOSemSim::mgoSim(term_ids, term_ids, semData = go_data, measure = &quot;Wang&quot;, combine = NULL) # Convert similarity matrix to edges edges &lt;- data.frame(from = rep(term_ids, each = length(term_ids)), to = rep(term_ids, times = length(term_ids)), similarity = as.vector(similarity_matrix)) # Filter out edges with zero similarity or self-loops edges &lt;- subset(edges, similarity &gt; 0 &amp; from != to) edges &lt;- edges %&gt;% dplyr::filter(similarity &gt;= 0.5) # Convert term IDs to names edges$to &lt;- Term(edges$to) edges$from &lt;- Term(edges$from) head(edges) ## from to similarity ## 1 RNA localization establishment of RNA localization 0.728 ## 2 ribosome biogenesis ribosomal small subunit biogenesis 0.848 ## 3 ribosome biogenesis ribosome assembly 0.623 ## 4 nuclear export RNA export from nucleus 0.616 ## 5 nuclear export cytosolic transport 0.616 ## 6 nuclear export protein export from nucleus 0.599 Now we can create a network plot to visualize the relationships between the enriched GO terms based on their semantic similarity. # Create an igraph object from the edges data frame g &lt;- graph_from_data_frame(edges, directed = FALSE) # Visualize the graph using ggraph ggraph(g, layout = &#39;fr&#39;) + # Fruchterman-Reingold layout geom_edge_link(aes(edge_alpha = 0.5)) + # Edges with some transparency geom_node_point(size = 5, color = &quot;blue&quot;) + # Nodes sized uniformly geom_node_text(aes(label = name), repel = TRUE, size = 3) + # Node labels theme_void() + # Clean theme without axes labs(title = &quot;GO Terms Semantic Similarity Network&quot;) # Title for the plot Edges based can also be defined by Jaccard similarity; defined as the size of the intersection each pair of GO terms divided by the size of their union # Define a function to compute Jaccard similarity jaccard_index &lt;- function(genes1, genes2) { length(intersect(genes1, genes2))/length(union(genes1, genes2)) } # Create an empty data frame to store edges edges &lt;- data.frame(from = character(), to = character(), similarity = numeric()) # Compute Jaccard similarity for each pair of terms for (i in 1:(length(term_ids) - 1)) { for (j in (i + 1):length(term_ids)) { similarity &lt;- jaccard_index(gene_lists[[i]], gene_lists[[j]]) if (similarity &gt; 0) { # Only keep edges with some overlap edges &lt;- rbind(edges, data.frame(from = term_ids[i], to = term_ids[j], similarity = similarity)) } } } edges &lt;- edges %&gt;% dplyr::filter(similarity &gt;= 0.5) # Convert term IDs to names edges$to &lt;- Term(edges$to) edges$from &lt;- Term(edges$from) Now we can create a network plot to visualize the relationships between the enriched GO terms based on the Jaccard similarity of their gene lists. # Create a graph from the edges g &lt;- graph_from_data_frame(edges, directed = FALSE) # Visualize the graph using ggraph ggraph(g, layout = &#39;fr&#39;) + # Fruchterman-Reingold layout geom_edge_link(aes(edge_alpha = 0.5)) + # Edges with some transparency geom_node_point(size = 5, color = &quot;blue&quot;) + geom_node_text(aes(label = name), repel = TRUE, size = 3) + # Node labels theme_void() + # Clean theme without axes labs(title = &quot;GO Terms Jaccard Overlap Network&quot;) The resulting network plots shows the relationships between the enriched GO terms based on either Semantic or Jaccard similarity of their gene lists. 8.0.6 Visualizing Enrichment Results Network Plot: The emapplot() function generates a network plot where each node represents an enriched gene set, and edges between nodes indicate the similarity or overlap between those gene sets. # Filter to top significant results first ego_filtered &lt;- ego ego_filtered@result &lt;- ego@result[1:50, ] # Take only top 50 results # Then create pairwise similarity pwt_filtered &lt;- pairwise_termsim(ego_filtered, method = &quot;JC&quot;) # Now emapplot should work better emapplot(pwt_filtered, showCategory = 20, node_label = &quot;category&quot;, layout = &quot;mds&quot;) + theme(legend.position = &quot;none&quot;) cnetplot(pwt_filtered, showCategory = 15, categorySize = &quot;pvalue&quot;, colorEdge = TRUE) + theme(legend.position = &quot;none&quot;) To save any of these figures if they become too cluttered, click on the Export button in the RStudio Plots tab and Save as PDF. In the pop-up window, change the PDF size to 24 x 32 to give a figure of appropriate size for the text labels. cnetplot: Visualizes connections between genes and top GO terms, highlighting shared pathways.This plot is particularly useful for hypothesis generation in identifying genes that may be important to several of the most affected processes. ## Extract the foldchanges OE_foldchanges &lt;- sigOE$log2FoldChange names(OE_foldchanges) &lt;- sigOE$gene ## cnetplot for the top 5 categories cnetplot(ego, categorySize = &quot;padj&quot;, node_label = &quot;all&quot;, showCategory = 5, foldChange = OE_foldchanges, vertex.label.font = 6) 8.0.7 GSEA Using clusterProfiler and fgsea Prepare fold changes, sort by expression, and run GSEA with gseGO() for clusterProfiler or fgseaSimple() for fgsea. ## Extract the foldchanges foldchanges &lt;- res_tableOE_tb$log2FoldChange ## Name each fold change with the gene name names(foldchanges) &lt;- res_tableOE_tb$gene ## Sort fold changes in decreasing order foldchanges &lt;- sort(foldchanges, decreasing = TRUE) We can explore the enrichment of BP Gene Ontology terms using gene set enrichment analysis (GSEA) using gene sets associated with BP Gene Ontology terms gseaGO &lt;- clusterProfiler::gseGO(geneList = foldchanges, ont = &quot;BP&quot;, keyType = &quot;SYMBOL&quot;, eps = 0, minGSSize = 20, maxGSSize = 300, pAdjustMethod = &quot;BH&quot;, pvalueCutoff = 0.05, verbose = TRUE, OrgDb = &quot;org.Hs.eg.db&quot;, by = &quot;fgsea&quot;) gseaGO_results &lt;- data.frame(gseaGO) 8.0.8 Visualizing GSEA Results Visualize GSEA results with dotplot() for significant categories and gseaplot2() for gene set ranks. dotplot(gseaGO, showCategory = 30) gseaplot2(gseaGO, geneSetID = 1:4) The emapplot clusters the 50 most significant (by padj) GO terms to visualize relationships between terms. gseaGO_filtered &lt;- gseaGO gseaGO_filtered@result &lt;- gseaGO@result[1:50, ] # Top 50 by p.adjust # Create pairwise similarity pwt &lt;- pairwise_termsim( gseaGO_filtered, method = &quot;JC&quot;, semData = NULL ) # Use safer emapplot parameters emapplot(pwt, showCategory = 20, # Reduced from 30 node_label = &quot;category&quot;, # Changed from &quot;all&quot; layout = &quot;mds&quot;) + theme(legend.position = &quot;none&quot;) 8.0.9 GSEA using fgsea GO annotations are updated regularly, and the GO terms associated with genes can change over time. This can lead to inconsistencies in the results of GO enrichment analyses when using different versions of the GO annotations. To address this issue, the GOenrichment package provides hGOBP.gmt a recently downloaded version of BP GO annotations. This file is a list of GO terms and their associated genes, which is used as input for the enrichment analysis. To run GSEA using the fgsea package, we need to load the gene sets from the hGOBP.gmt file and the gene-level statistics from the foldchanges vector. We can then run the GSEA analysis using the fgseaSimple function. # Let&#39;s look at the hGOBP.gmt file hGOBP.gmt[1] ## $`MITOCHONDRIAL GENOME MAINTENANCE` ## [1] &quot;AKT3&quot; &quot;CHCHD4&quot; &quot;DNA2&quot; &quot;DNAJA3&quot; &quot;ENDOG&quot; &quot;FLCN&quot; ## [7] &quot;LIG3&quot; &quot;LONP1&quot; &quot;MEF2A&quot; &quot;METTL4&quot; &quot;MGME1&quot; &quot;MPV17&quot; ## [13] &quot;OPA1&quot; &quot;PARP1&quot; &quot;PIF1&quot; &quot;POLG&quot; &quot;POLG2&quot; &quot;PPARGC1A&quot; ## [19] &quot;PRIMPOL&quot; &quot;RRM1&quot; &quot;RRM2B&quot; &quot;SESN2&quot; &quot;SLC25A33&quot; &quot;SLC25A36&quot; ## [25] &quot;SLC25A4&quot; &quot;SSBP1&quot; &quot;STOX1&quot; &quot;TOP3A&quot; &quot;TP53&quot; &quot;TWNK&quot; ## [31] &quot;TYMP&quot; fgseaRes &lt;- fgsea::fgseaSimple(pathways = hGOBP.gmt, stats = foldchanges, nperm = 1000, maxSize = 300, minSize = 20) fgsea &lt;- data.frame(fgseaRes, stringsAsFactors = F) w = which(fgsea$ES &gt; 0) fposgsea &lt;- fgsea[w, ] fposgsea &lt;- fposgsea %&gt;% arrange(padj) plotEnrichment(hGOBP.gmt[[&quot;EXTRACELLULAR MATRIX ORGANIZATION&quot;]], foldchanges) The fgseaSimple function returns a list of enriched gene sets and the enrichment score (ES). We are going to compare these results to running the GO enrichment function runGORESP. Let’s first load the GOenrichment package and check the available functions: # Uncomment the following if you haven&#39;t yet installed GOenrichment. # devtools::install_github(&#39;gurinina/GOenrichment&#39;) library(GOenrichment) ls(&quot;package:GOenrichment&quot;) ## [1] &quot;compSCORE&quot; &quot;hGOBP.gmt&quot; &quot;hyperG&quot; &quot;runGORESP&quot; &quot;runNetwork&quot; ## [6] &quot;visSetup&quot; 8.0.10 GOenrichment Package Analysis runGORESP uses over-representation analysis to identify enriched GO terms and returns two data.frames; of enriched GO terms (nodes) and GO term relationships (edges). compSCOREevaluates a matrix of fitness scores to identify the querySet with scores above a specified significance threshold. We’ll use a significance cutoff of 0.58, corresponding to a 1.5x change in expression. args(runGORESP) ## function (scoreMat, curr_exp = &quot;test&quot;, fdrThresh = 0.2, bp_path = NULL, ## bp_input = NULL, go_path = NULL, go_input = NULL, minSetSize = 5, ## maxSetSize = 300) ## NULL # ?runGORESP # Define the query set matx &lt;- cbind(foldchanges, foldchanges) scoreMat = compSCORE(matx, coln = 1, sig = 0.58) head(scoreMat) ## index score gene ## HSPA6 1 6.246267 HSPA6 ## MOV10 1 5.079630 MOV10 ## ASCL1 1 4.441203 ASCL1 ## HSPA7 1 3.637040 HSPA7 ## SCRT1 1 2.925440 SCRT1 ## SIGLEC14 1 2.615129 SIGLEC14 hresp = runGORESP(fdrThresh = 0.2, scoreMat = scoreMat, bp_input = hGOBP.gmt, go_input = NULL, minSetSize = 20, maxSetSize = 300) names(hresp$edgeMat) ## [1] &quot;source&quot; &quot;target&quot; &quot;overlapCoeff&quot; &quot;width&quot; &quot;label&quot; names(hresp$enrichInfo) ## [1] &quot;filename&quot; &quot;term&quot; &quot;nGenes&quot; ## [4] &quot;nQuery&quot; &quot;nOverlap&quot; &quot;querySetFraction&quot; ## [7] &quot;geneSetFraction&quot; &quot;foldEnrichment&quot; &quot;P&quot; ## [10] &quot;FDR&quot; &quot;overlapGenes&quot; &quot;maxOverlapGeneScore&quot; ## [13] &quot;cluster&quot; &quot;id&quot; &quot;size&quot; ## [16] &quot;formattedLabel&quot; head(hresp$enrichInfo[, c(2, 3, 4, 5, 10)]) ## term nGenes nQuery nOverlap FDR ## 1 EXTRACELLULAR MATRIX ORGANIZATION 293 722 39 5.35e-09 ## 2 EXTRACELLULAR STRUCTURE ORGANIZATION 294 724 39 5.35e-09 ## 3 EXTERNAL ENCAPSULATING STRUCTURE ORGANIZATION 294 724 39 5.35e-09 ## 4 PROTEIN REFOLDING 27 727 8 3.75e-03 ## 5 REGULATION OF VASCULATURE DEVELOPMENT 273 739 25 2.23e-02 ## 6 CELL ADHESION MEDIATED BY INTEGRIN 82 748 12 2.45e-02 Let’s check the overlap between the enriched terms found using runGORESP and those found using fgseaSimple as they used the same GO term libraries: w = which(fposgsea$padj &lt;= 0.2) lens &lt;- length(intersect(fposgsea$pathway[w], hresp$enrichInfo$term)) length(w) ## [1] 481 dim(hresp$enrichInfo) ## [1] 57 16 percent_overlap &lt;- lens/nrow(hresp$enrichInfo) * 100 percent_overlap ## [1] 75.4386 80%, that’s very good because we are using two different GO enrichment methods, over-representation analysis and GSEA. We can visualize the results of the GO enrichment analysis using the visNetwork package. This package allows us to create interactive network visualizations. The equivalent function in the GOenrichment package is runNetwork: We use thevisSetup function to prepare the data for network visualization. We then run the runNetwork function to generate the interactive network plot. vis = visSetup(hresp$enrichInfo, hresp$edgeMat) GOenrichment::runNetwork(vis$nodes, vis$edges, main = &quot;MOV10 Overexpression GO Enrichment&quot;) This network analysis is based on Cytoscape, an open source bioinformatics software platform for visualizing molecular interaction networks. out of all the GO packages. Exercise points = +4 Perform a GO enrichment analysis using the runGORESP function from the GOenrichment package using the res_tableKD_tb$log2FoldChange and cbind to build an input matrix. Use a significance threshold of 0.58 and an FDR threshold of 0.2. Save the results in a variable called kresp. Visualize the enriched GO terms using the runNetwork function from the GOenrichment package. Save the results in a variable called kvis. 8.0.11 Other tools and resources GeneMANIA. GeneMANIA finds other genes that are related to a set of input genes, using a very large set of functional association data curated from the literature. ReviGO. Revigo is an online GO enrichment tool that allows you to copy-paste your significant gene list and your background gene list. The output is a visualization of enriched GO terms in a hierarchical tree. AmiGO. AmiGO is the current official web-based set of tools for searching and browsing the Gene Ontology database. etc. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
